---
layout: default
---

<div class="home">
  <h1 class="simple-intro">hi, i'm pj. i like to code</h1>
  
  <div id="game-container">
    <div id="game-canvas"></div>
    <div id="game-ui">
      <div id="instructions">
        ← → to move left/right <br>
        Catch the neon shapes to discover my latest GitHub projects <br>
        Projects shown by most recent activity
      </div>
    </div>
    <div id="game-overlay">
      <div id="start-screen" class="overlay-screen">
        <div class="logo">NEON WAVE</div>
        <div class="start-button">PRESS SPACE TO START</div>
      </div>
    </div>
  </div>
</div>

<script>
// Game variables
let scene, camera, renderer, player;
let gameStarted = false;
let gameOver = false;
let score = 0;
let highScore = 0;
let speed = 0.2;
let obstacles = [];
let collectibles = [];
let level = 1;
let playerSize = 0.6;
let lanes = [-2, 0, 2];
let currentLane = 1; // Center lane (0)
let animationId;
let gridHelper;
let sunGeometry;
let sun;
let stars = [];
let neonColors = [0x00ffff, 0xff00ff, 0xffff00, 0xff0099, 0x00ff99];
let githubRepos = []; // Will hold the GitHub repository data
let explodingTexts = []; // Will hold the exploding text particles

// Fetch GitHub repositories
async function fetchGitHubRepos() {
  try {
    const username = 'pj4533';
    
    // Get repos sorted by most recently updated
    // The 'updated' sort parameter sorts by the last time the repo was pushed to
    const response = await fetch(`https://api.github.com/users/${username}/repos?sort=updated&direction=desc&per_page=50`);
    
    if (!response.ok) {
      throw new Error('Failed to fetch repositories');
    }
    
    const repos = await response.json();
    console.log('Fetched repos:', repos.length);
    
    // Filter out forks, repos without descriptions, unusual names, and repos not updated in the past year
    const oneYearAgo = new Date();
    oneYearAgo.setFullYear(oneYearAgo.getFullYear() - 1); // Date from 1 year ago
    
    const filteredRepos = repos
      .filter(repo => {
        // Parse the update timestamp
        const lastUpdated = new Date(repo.pushed_at || repo.updated_at);
        
        // Skip forks, empty descriptions, unusual names, and repos not updated in the past year
        return !repo.fork && 
               repo.description && 
               repo.description.trim() !== '' &&
               repo.name && 
               repo.name.length > 1 && // Skip very short names
               !/^\[.*\]$/.test(repo.name) && // Skip names that are just brackets
               lastUpdated > oneYearAgo; // Only repos updated in the past year
      })
      .map(repo => ({
        name: repo.name,
        description: repo.description,
        url: repo.html_url,
        stars: repo.stargazers_count,
        // Handle unusual language values
        language: (repo.language && repo.language.toLowerCase() !== 'shift') ? repo.language : null,
        updated_at: repo.updated_at,
        pushed_at: repo.pushed_at, // When the repo was last pushed to
        color: neonColors[Math.floor(Math.random() * neonColors.length)]
      }));
    
    // Sort by pushed_at date (most recent commit activity first)
    filteredRepos.sort((a, b) => {
      const dateA = new Date(a.pushed_at || a.updated_at);
      const dateB = new Date(b.pushed_at || b.updated_at);
      return dateB - dateA; // Descending order (newest first)
    });
    
    console.log('Filtered repos updated in past year:', filteredRepos.length);
    
    // If we don't have any recently updated repos, relax the time constraint to 2 years
    if (filteredRepos.length === 0) {
      console.log('No repos updated in the past year, extending to 2 years');
      const twoYearsAgo = new Date();
      twoYearsAgo.setFullYear(twoYearsAgo.getFullYear() - 2);
      
      filteredRepos.push(...repos
        .filter(repo => {
          const lastUpdated = new Date(repo.pushed_at || repo.updated_at);
          return !repo.fork && 
                 repo.description && 
                 repo.description.trim() !== '' &&
                 repo.name && 
                 repo.name.length > 1 &&
                 !/^\[.*\]$/.test(repo.name) &&
                 lastUpdated > twoYearsAgo && 
                 lastUpdated <= oneYearAgo;
        })
        .map(repo => ({
          name: repo.name,
          description: repo.description,
          url: repo.html_url,
          stars: repo.stargazers_count,
          language: (repo.language && repo.language.toLowerCase() !== 'shift') ? repo.language : null,
          updated_at: repo.updated_at,
          pushed_at: repo.pushed_at,
          color: neonColors[Math.floor(Math.random() * neonColors.length)]
        }))
      );
    }
    
    // Log the repos that will be shown
    console.log(`Showing ${filteredRepos.length} repos updated in the past ${filteredRepos.length === 0 ? '2 years' : 'year'}:`);
    filteredRepos.forEach(repo => {
      console.log(`- ${repo.name}: Last updated ${new Date(repo.pushed_at || repo.updated_at).toLocaleDateString()}`);
    });
    
    return filteredRepos;
  } catch (error) {
    console.error('Error fetching GitHub repos:', error);
    // Fallback data in case the API fails - with current dates to ensure they're shown
    const today = new Date().toISOString();
    return [
      { 
        name: 'NeonWave', 
        description: 'A retro-styled WebGL game with Three.js', 
        language: 'JavaScript',
        pushed_at: today,
        updated_at: today,
        stars: 5,
        color: 0xff9900 
      },
      { 
        name: 'OpenPics', 
        description: 'Open source iOS app for viewing images from various services', 
        language: 'Swift',
        pushed_at: today,
        updated_at: today,
        stars: 12,
        color: 0x00ffff 
      },
      { 
        name: 'SwiftSockets', 
        description: 'A simple socket wrapper for Swift', 
        language: 'Swift',
        pushed_at: today,
        updated_at: today,
        stars: 8,
        color: 0xff00ff 
      },
      { 
        name: 'WifiMonitor', 
        description: 'Raspberry Pi based WiFi monitoring tool', 
        language: 'Python',
        pushed_at: today,
        updated_at: today,
        stars: 3,
        color: 0xffff00 
      },
      { 
        name: 'RetroUI', 
        description: 'Retro UI components for modern web applications', 
        language: 'TypeScript',
        pushed_at: today,
        updated_at: today,
        stars: 7,
        color: 0x00ff99 
      },
    ];
  }
}

// TextParticle class for exploding text
class TextParticle {
  constructor(text, position, color, isRepoName = false) {
    this.text = text;
    this.position = position.clone();
    this.isRepoName = isRepoName; // Flag to identify if this is a repo name (for special treatment)
    
    // Minimal movement for maximum readability - almost static text
    this.velocity = new THREE.Vector3(
      (Math.random() - 0.5) * 0.02, // Barely any horizontal movement
      (Math.random() - 0.5) * 0.01 + 0.02, // Extremely gentle upward drift
      (Math.random() - 0.5) * 0.02  // Minimal z-movement
    );
    
    // Almost no rotation for maximum readability
    this.rotation = new THREE.Vector3(
      0, // No initial x rotation
      0, // No initial y rotation
      (Math.random() - 0.5) * 0.05 // Tiny initial z rotation only
    );
    
    // Extremely slow rotation for optimal reading
    this.rotationSpeed = new THREE.Vector3(
      0, // No x rotation
      0, // No y rotation
      (Math.random() - 0.5) * 0.005 // Extremely slow z rotation only
    );
    
    this.color = color;
    this.opacity = 1;
    
    // Much larger scale, especially for repo names
    this.scale = isRepoName ? 2.5 : 1.5;
    
    // Extremely slow fade for maximum readability
    this.life = 1.0;
    this.lifeSpeed = isRepoName ? 0.0015 : 0.004; // Dramatically slower fade for better reading
    
    // Much longer delay before fading starts for better readability
    this.delayFade = isRepoName ? 180 : 60; // Many more frames before starting to fade
    
    this.createMesh();
  }

  createMesh() {
    try {
      // Create canvas for text
      const canvas = document.createElement('canvas');
      const context = canvas.getContext('2d');
      canvas.width = 1024; // Double resolution for better text quality
      canvas.height = 512;
      
      // Safely convert color to hex (handle undefined or invalid colors)
      let hexColor;
      try {
        hexColor = (this.color || 0xffffff).toString(16).padStart(6, '0');
      } catch (e) {
        console.error('Color conversion error:', e);
        hexColor = 'ffffff'; // Default to white if there's a problem
      }
      
      // Create a subtler gradient for cleaner text with less glow
      const gradient = context.createLinearGradient(0, 0, canvas.width/2, canvas.height/2);
      gradient.addColorStop(0, `#${hexColor}`); 
      gradient.addColorStop(1, `#${hexColor}ee`); // Slightly transparent color (less white)
      
      // Set font properties for maximum clarity - larger and bolder font
      const fontSize = this.isRepoName ? 80 : 54; // Even bigger font for better readability
      context.font = `900 ${fontSize}px "JetBrains Mono", monospace`; // Extra bold weight (900)
      context.fillStyle = gradient;
      context.strokeStyle = '#000000';
      context.lineWidth = 8; // Much thicker outline for better readability and contrast
      context.textAlign = 'center';
      context.textBaseline = 'middle';
      
      // Clear canvas
      context.clearRect(0, 0, canvas.width, canvas.height);
      
      // Very minimal shadow blur for maximum clarity and reduced glow
      context.shadowColor = `#${hexColor}`;
      context.shadowBlur = 4; // Significantly reduced blur for much less glow
      context.shadowOffsetX = 0;
      context.shadowOffsetY = 0;
      
      // Make sure text is always a string
      const safeText = String(this.text || '');
      
      // For repository names, add extra visibility features
      if (this.isRepoName) {
        // Add a darker, larger background box with border for maximum contrast
        const textMetrics = context.measureText(safeText);
        const textWidth = textMetrics.width;
        const textHeight = fontSize * 1.2;
        
        // First draw outer glow border
        context.fillStyle = `#${hexColor}33`; // Semi-transparent color matching the text
        context.fillRect(
          canvas.width/2 - textWidth/2 - 28,
          canvas.height/2 - textHeight/2 - 18,
          textWidth + 56,
          textHeight + 36
        );
        
        // Then draw solid black background
        context.fillStyle = 'rgba(0, 0, 0, 0.85)'; // Darker background
        context.fillRect(
          canvas.width/2 - textWidth/2 - 24,
          canvas.height/2 - textHeight/2 - 14,
          textWidth + 48, 
          textHeight + 28
        );
        
        // Reset fill style to gradient
        context.fillStyle = gradient;
        
        // Extremely minimal glow for maximum clarity (single pass with much less blur)
        context.shadowBlur = 3; // Very minimal blur for cleaner text
        context.shadowColor = `#${hexColor}`;
        context.strokeText(safeText, canvas.width / 2, canvas.height / 2);
      }
      
      // Draw text (first stroke for outline, then fill)
      const textX = canvas.width / 2;
      const textY = canvas.height / 2;
      context.strokeText(safeText, textX, textY);
      context.fillText(safeText, textX, textY);
      
      // Create texture from canvas (optimized settings)
      const texture = new THREE.CanvasTexture(canvas);
      texture.minFilter = THREE.LinearFilter;
      texture.anisotropy = 4; // Reduced anisotropy for better performance while maintaining quality
      
      // Create material with transparency (less glow effect)
      const material = new THREE.MeshBasicMaterial({
        map: texture,
        transparent: true,
        opacity: this.opacity,
        side: THREE.DoubleSide,
        blending: THREE.NormalBlending, // Standard blending for cleaner, less glowy text
        depthWrite: false, // Prevents z-fighting with other text
        depthTest: true
      });
      
      // Create plane geometry for the text
      const geometry = new THREE.PlaneGeometry(3, 1.5); // Larger plane for text
      
      // Create mesh with geometry and material
      this.mesh = new THREE.Mesh(geometry, material);
      this.mesh.position.copy(this.position);
      this.mesh.scale.set(this.scale, this.scale, this.scale);
      
      // Add the repo-text class
      this.mesh.userData.className = 'repo-text';
      
      // Make sure camera exists before looking at it
      if (camera) {
        // Always face the camera (billboard effect)
        this.mesh.lookAt(camera.position);
      }
    } catch (err) {
      console.error('Error creating text mesh:', err);
      
      // Create a fallback simple mesh if text creation fails
      const geometry = new THREE.PlaneGeometry(1, 0.5);
      const material = new THREE.MeshBasicMaterial({
        color: 0xffffff,
        transparent: true,
        opacity: this.opacity
      });
      this.mesh = new THREE.Mesh(geometry, material);
      this.mesh.position.copy(this.position);
    }
  }
  
  update() {
    try {
      if (!this.mesh) {
        console.error('Missing mesh in TextParticle update');
        return false; // Return false to remove this particle
      }
      
      // Update position with gentle movement
      this.position.add(this.velocity);
      this.mesh.position.copy(this.position);
      
      // Slight rotation for subtle motion but not too much to make it hard to read
      this.rotation.x += this.rotationSpeed.x;
      this.rotation.y += this.rotationSpeed.y;
      this.rotation.z += this.rotationSpeed.z;
      
      // Always look at camera first (billboard effect) if camera exists
      if (camera) {
        try {
          this.mesh.lookAt(camera.position);
          // Apply only Z rotation to keep text oriented correctly
          this.mesh.rotateZ(this.rotation.z * 0.3);
        } catch (e) {
          console.error('Error rotating text:', e);
        }
      }
      
      // Delayed fade effect - only start fading after delay
      if (this.delayFade > 0) {
        this.delayFade--;
      } else {
        this.life -= this.lifeSpeed;
        
        // For smoother fade out, especially for repo names
        if (this.isRepoName) {
          // Repo names stay fully visible longer
          this.opacity = this.life > 0.7 ? 1.0 : this.life;
        } else {
          this.opacity = this.life;
        }
        
        if (this.mesh.material) {
          this.mesh.material.opacity = this.opacity;
        }
      }
      
      // Gentle scale increase - different for repo names vs description words
      let scaleFactor;
      if (this.isRepoName) {
        // Repo names grow more slowly
        scaleFactor = 1 + (1 - this.life) * 0.3;
      } else {
        // Description words can grow a bit more
        scaleFactor = 1 + (1 - this.life) * 0.5;
      }
      
      // Apply scale (safely)
      try {
        this.mesh.scale.set(this.scale * scaleFactor, this.scale * scaleFactor, this.scale * scaleFactor);
      } catch (e) {
        console.error('Error scaling text:', e);
      }
      
      // Return true if still alive, false if should be removed
      return this.life > 0;
    } catch (err) {
      console.error('Error in TextParticle update:', err);
      return false; // Remove this particle on error
    }
  }
}

// Create exploding text effect for repositories
function createExplodingRepoText(position, repo) {
  try {
    if (!repo || !position) {
      console.error('Invalid repo or position for exploding text');
      return;
    }
    
    console.log("Showing repo:", 
      repo.name || 'Unnamed', 
      repo.description || 'No description');
    
    // Move repo name to an optimal centered viewing position (adjusted without description words)
    const namePosition = position.clone();
    namePosition.y += 0.8; // Slightly raised position (less than before since we removed description words)
    namePosition.z -= 1; // Bring slightly closer to camera for emphasis

    // Ensure repo name is valid
    const repoName = repo.name ? String(repo.name).toUpperCase() : 'UNNAMED REPO';
    
    // Create particle for repo name with isRepoName flag set to true
    const nameParticle = new TextParticle(repoName, namePosition, repo.color || 0xffff00, true);
    
    // Only add to scene if mesh was created successfully
    if (nameParticle.mesh) {
      scene.add(nameParticle.mesh);
      explodingTexts.push(nameParticle);
    }
    
    // Skip description words - only showing repo names now
    // Description words have been removed for clarity
    
    // Add language and stars information if available
    if (repo.language || repo.stars) {
      setTimeout(() => {
        let infoText = '';
        // Only add language if it exists and isn't unusual
        if (repo.language && repo.language.length > 1 && repo.language.toLowerCase() !== 'shift') {
          infoText += `[${repo.language}]`;
        }
        
        // Add stars if available
        if (repo.stars && repo.stars > 0) infoText += ` ★ ${repo.stars}`;
        
        // Only proceed if we have valid info text
        if (infoText && infoText.trim() !== '') {
          // Position directly below the repository name for better organization
          const infoPosition = namePosition.clone();
          infoPosition.y -= 0.8; // Position further down without description words
          
          // Create info text particle with eye-catching color and treat as important text
          const infoParticle = new TextParticle(infoText, infoPosition, 0xffff00, true); // true for more prominence
          
          if (infoParticle.mesh) {
            scene.add(infoParticle.mesh);
            explodingTexts.push(infoParticle);
          }
        }
      }, 200); // Show more quickly after repo name
    }
  } catch (err) {
    console.error('Error creating repo text effect:', err);
  }
}

// Initialize the game
function init() {
  // Create scene
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x000000);
  
  // Add fog for depth effect - purple fog for 80s vibe
  scene.fog = new THREE.Fog(0x110022, 8, 35);
  
  // Create camera
  camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
  camera.position.set(0, 1.5, 5);
  camera.lookAt(0, 0, -10);
  
  // Create renderer with post-processing effects
  renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.getElementById('game-canvas').appendChild(renderer.domElement);
  
  // Add lights
  const ambientLight = new THREE.AmbientLight(0x222222);
  scene.add(ambientLight);
  
  // Add point lights for neon effect
  const blueLight = new THREE.PointLight(0x00ffff, 1, 50);
  blueLight.position.set(-10, 15, -30);
  scene.add(blueLight);
  
  const pinkLight = new THREE.PointLight(0xff00ff, 1, 50);
  pinkLight.position.set(10, 15, -10);
  scene.add(pinkLight);
  
  // Create starfield backdrop
  createStarfield();
  
  // Create retro sun
  createRetroCyberpunkSun();
  
  // Create track
  createTrack();
  
  // Create player
  createPlayer();
  
  // Fetch GitHub repositories - load immediately on page load
  console.log('Loading GitHub repositories...');
  fetchGitHubRepos().then(repos => {
    githubRepos = repos;
    console.log('Loaded GitHub repos:', githubRepos.length);
    
    // Only fetch repos once at launch - no automatic refreshes
    console.log('GitHub repos loaded once at launch - will not automatically refresh');
  });
  
  // Handle window resize
  window.addEventListener('resize', onWindowResize, false);
  
  // Add key events listener
  document.addEventListener('keydown', handleKeyDown);
  
  // Initial UI setup
  updateScore(0);
  
  // Check local storage for high score
  try {
    if (localStorage.getItem('neonWaveHighScore')) {
      highScore = parseInt(localStorage.getItem('neonWaveHighScore'));
      console.log('Loaded high score:', highScore);
    }
  } catch (err) {
    console.error('Error loading high score:', err);
  }
  
  // Start animation loop
  animate();
}

// Handle keyboard input
function handleKeyDown(event) {
  // Prevent default action for arrow keys and space
  if (event.key === ' ' || 
      event.key === 'ArrowLeft' || 
      event.key === 'ArrowRight' || 
      event.key === 'ArrowUp' || 
      event.key === 'ArrowDown') {
    event.preventDefault();
  }
  
  // Handle spacebar to start the game
  if (event.key === ' ') {
    if (!gameStarted) {
      startGame();
      return;
    }
    
    // We can also use spacebar as an alternative to show a random repo
    if (Math.random() < 0.05) { // Increased chance to trigger fun repo fact
      if (githubRepos.length > 0) {
        const randomRepo = githubRepos[Math.floor(Math.random() * githubRepos.length)];
        
        // Create a special centered text effect
        const center = new THREE.Vector3(0, 1.5, 0);
        createExplodingRepoText(center, randomRepo);
      }
    }
  }
  
  // Add R key to refresh the game and repos
  if (event.key === 'r' || event.key === 'R') {
    if (gameStarted) {
      refreshGame();
      return;
    }
  }
  
  // Only handle movement if game is active
  if (!gameStarted) return;
  
  // Handle movement with arrow keys
  if (event.key === 'ArrowLeft') {
    if (currentLane > 0) {
      currentLane--;
      player.rotation.z = 0.2;
      setTimeout(() => {
        if (player) player.rotation.z = 0;
      }, 200);
    }
  } else if (event.key === 'ArrowRight') {
    if (currentLane < 2) {
      currentLane++;
      player.rotation.z = -0.2;
      setTimeout(() => {
        if (player) player.rotation.z = 0;
      }, 200);
    }
  }
}

// Create starfield backdrop (optimized)
function createStarfield() {
  const starGeometry = new THREE.BufferGeometry();
  const starMaterial = new THREE.PointsMaterial({
    color: 0xffffff,
    size: 0.1,
  });
  
  const starVertices = [];
  // Reduced number of stars for better performance
  for (let i = 0; i < 700; i++) {
    const x = (Math.random() - 0.5) * 100;
    const y = (Math.random() - 0.5) * 100;
    const z = -Math.random() * 100;
    starVertices.push(x, y, z);
  }
  
  starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));
  stars = new THREE.Points(starGeometry, starMaterial);
  scene.add(stars);
}

// Create a retro cyberpunk sun
function createRetroCyberpunkSun() {
  // Create the sun circle
  sunGeometry = new THREE.CircleGeometry(10, 32);
  const sunMaterial = new THREE.MeshBasicMaterial({
    color: 0xff00ff,
    side: THREE.DoubleSide,
    wireframe: true,
  });
  
  sun = new THREE.Mesh(sunGeometry, sunMaterial);
  sun.position.z = -50;
  sun.position.y = 15;
  scene.add(sun);
  
  // Create concentric circles for retro sun effect
  for (let i = 1; i < 5; i++) {
    const ringGeometry = new THREE.RingGeometry(i * 2, i * 2 + 0.1, 32);
    const ringMaterial = new THREE.MeshBasicMaterial({
      color: i % 2 === 0 ? 0x00ffff : 0xff00ff,
      side: THREE.DoubleSide,
      transparent: true,
      opacity: 0.7
    });
    const ring = new THREE.Mesh(ringGeometry, ringMaterial);
    ring.position.z = -50;
    ring.position.y = 15;
    scene.add(ring);
  }
}

// Create the game track
function createTrack() {
  // Main track is dark with grid lines
  const trackGeometry = new THREE.PlaneGeometry(10, 1000);
  const trackMaterial = new THREE.MeshBasicMaterial({ 
    color: 0x000000,
    wireframe: false
  });
  const track = new THREE.Mesh(trackGeometry, trackMaterial);
  track.rotation.x = -Math.PI / 2;
  track.position.z = -500;
  scene.add(track);
  
  // Add 80s-style neon grid lines
  gridHelper = new THREE.GridHelper(100, 50, 0xff00ff, 0x00ffff);
  gridHelper.position.y = 0.01;
  gridHelper.position.z = -500;
  scene.add(gridHelper);
  
  // Add lane markers
  for (let lane of lanes) {
    const markerGeometry = new THREE.PlaneGeometry(0.1, 1000);
    const markerMaterial = new THREE.MeshBasicMaterial({
      color: 0x00ffff,
      side: THREE.DoubleSide,
      transparent: true,
      opacity: 0.5
    });
    const marker = new THREE.Mesh(markerGeometry, markerMaterial);
    marker.position.x = lane;
    marker.position.y = 0.01;
    marker.position.z = -500;
    marker.rotation.x = -Math.PI / 2;
    scene.add(marker);
  }
  
  // Add side barriers with neon effect
  const leftBarrierGeometry = new THREE.BoxGeometry(0.2, 0.5, 1000);
  const rightBarrierGeometry = new THREE.BoxGeometry(0.2, 0.5, 1000);
  
  const leftBarrierMaterial = new THREE.MeshBasicMaterial({ color: 0xff00ff });
  const rightBarrierMaterial = new THREE.MeshBasicMaterial({ color: 0x00ffff });
  
  const leftBarrier = new THREE.Mesh(leftBarrierGeometry, leftBarrierMaterial);
  const rightBarrier = new THREE.Mesh(rightBarrierGeometry, rightBarrierMaterial);
  
  leftBarrier.position.x = -5.1;
  leftBarrier.position.y = 0.25;
  leftBarrier.position.z = -500;
  
  rightBarrier.position.x = 5.1;
  rightBarrier.position.y = 0.25;
  rightBarrier.position.z = -500;
  
  scene.add(leftBarrier);
  scene.add(rightBarrier);
}

// Create player - 80s style car
function createPlayer() {
  // Create car body
  const carGroup = new THREE.Group();
  
  // Main body - neon colored hovercar
  const bodyGeometry = new THREE.BoxGeometry(playerSize + 0.1, playerSize / 2, playerSize + 0.3);
  const bodyMaterial = new THREE.MeshLambertMaterial({ 
    color: 0x00ffff,
    emissive: 0x00ffff,
    emissiveIntensity: 0.5
  });
  const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
  carGroup.add(body);
  
  // Top part
  const topGeometry = new THREE.BoxGeometry(playerSize - 0.1, playerSize / 3, playerSize - 0.1);
  const topMaterial = new THREE.MeshLambertMaterial({ 
    color: 0x0000ff,
    emissive: 0x0000ff,
    emissiveIntensity: 0.2
  });
  const top = new THREE.Mesh(topGeometry, topMaterial);
  top.position.y = 0.25;
  carGroup.add(top);
  
  // Add lights for the car
  const frontLightGeometry = new THREE.BoxGeometry(0.1, 0.1, 0.1);
  const frontLightMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });
  
  const leftLight = new THREE.Mesh(frontLightGeometry, frontLightMaterial);
  leftLight.position.set(-0.2, 0, 0.3);
  carGroup.add(leftLight);
  
  const rightLight = new THREE.Mesh(frontLightGeometry, frontLightMaterial);
  rightLight.position.set(0.2, 0, 0.3);
  carGroup.add(rightLight);
  
  // Add neon glow
  const playerLight = new THREE.PointLight(0x00ffff, 1, 3);
  playerLight.position.set(0, 0.5, 0);
  carGroup.add(playerLight);
  
  // Position the whole car
  carGroup.position.y = playerSize / 2;
  carGroup.position.z = 0;
  carGroup.position.x = lanes[currentLane];
  
  player = carGroup;
  scene.add(player);
}

// Create obstacles - glitchy retro objects
function createObstacle() {
  const lane = Math.floor(Math.random() * 3);
  const obstacleType = Math.floor(Math.random() * 3);
  let obstacle;
  
  switch (obstacleType) {
    case 0: // Glitchy cube
      const cubeGroup = new THREE.Group();
      
      // Main glitchy cube
      const cubeGeometry = new THREE.BoxGeometry(1, 1, 1);
      const cubeMaterial = new THREE.MeshBasicMaterial({ 
        color: 0xff0000,
        wireframe: true,
        transparent: true,
        opacity: 0.9
      });
      const cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
      cubeGroup.add(cube);
      
      // Add glitching effect with multiple frames that randomly display
      for (let i = 0; i < 3; i++) {
        const glitchFrame = new THREE.Mesh(
          new THREE.BoxGeometry(1.2, 1.2, 1.2),
          new THREE.MeshBasicMaterial({
            color: 0xff0000,
            wireframe: true,
            transparent: true,
            opacity: 0.3
          })
        );
        glitchFrame.visible = false;
        cubeGroup.add(glitchFrame);
      }
      
      // Add intense red glow
      const cubeLight = new THREE.PointLight(0xff0000, 1, 3);
      cubeLight.position.set(0, 0, 0);
      cubeGroup.add(cubeLight);
      
      // Set up glitching animation
      setInterval(() => {
        if (cubeGroup.parent) {  // Check if still in the scene
          // Randomly show/hide glitch frames
          cubeGroup.children.forEach((child, index) => {
            if (index > 0 && index < 4) { // Skip the main cube and light
              child.visible = Math.random() > 0.7;
              child.rotation.x = Math.random() * Math.PI;
              child.rotation.z = Math.random() * Math.PI;
            }
          });
          
          // Randomly scale the main cube
          cube.scale.set(
            0.8 + Math.random() * 0.4,
            0.8 + Math.random() * 0.4,
            0.8 + Math.random() * 0.4
          );
        }
      }, 80);
      
      obstacle = cubeGroup;
      break;
      
    case 1: // VHS static-like noise
      const noiseGroup = new THREE.Group();
      
      // Create multiple glitchy planes
      for (let i = 0; i < 5; i++) {
        const noiseGeometry = new THREE.BoxGeometry(1.2, 0.1, 0.6);
        const noiseColor = (i % 2 === 0) ? 0xff3333 : 0xff0000;
        const noiseMaterial = new THREE.MeshLambertMaterial({ 
          color: noiseColor,
          emissive: noiseColor,
          emissiveIntensity: 0.9,
          transparent: true,
          opacity: 0.9
        });
        const noisePlane = new THREE.Mesh(noiseGeometry, noiseMaterial);
        noisePlane.position.y = -0.25 + (i * 0.1);
        noiseGroup.add(noisePlane);
      }
      
      // Add intense red warning light
      const noiseLight = new THREE.PointLight(0xff0000, 1.5, 4);
      noiseLight.position.set(0, 0, 0);
      noiseGroup.add(noiseLight);
      
      // Set up glitching
      setInterval(() => {
        if (noiseGroup.parent) {  // Check if still in the scene
          noiseGroup.children.forEach((child, index) => {
            if (index < 5) { // Only affect the planes, not the light
              // Randomly change opacity and position
              child.material.opacity = 0.7 + Math.random() * 0.3;
              child.position.x = (Math.random() - 0.5) * 0.3;
              child.position.y = -0.25 + (index * 0.1) + (Math.random() - 0.5) * 0.1;
              child.scale.x = 0.8 + Math.random() * 0.5;
            }
          });
        }
      }, 50);
      
      obstacle = noiseGroup;
      break;
      
    case 2: // Computer virus symbol
      const virusGroup = new THREE.Group();
      
      // Create multiple tetrahedrons that overlap
      for (let i = 0; i < 3; i++) {
        const baseGeometry = new THREE.TetrahedronGeometry(0.6, 0);
        const baseMaterial = new THREE.MeshBasicMaterial({ 
          color: 0xff0000,
          wireframe: true,
          transparent: true,
          opacity: 0.8
        });
        const baseShape = new THREE.Mesh(baseGeometry, baseMaterial);
        baseShape.rotation.set(
          Math.random() * Math.PI,
          Math.random() * Math.PI,
          Math.random() * Math.PI
        );
        virusGroup.add(baseShape);
      }
      
      // Add flashing sphere in center
      const sphereGeometry = new THREE.SphereGeometry(0.4, 8, 8);
      const sphereMaterial = new THREE.MeshBasicMaterial({
        color: 0xff0000,
        transparent: true,
        opacity: 0.7
      });
      const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
      virusGroup.add(sphere);
      
      // Stronger red warning light
      const warning = new THREE.PointLight(0xff0000, 2, 5);
      warning.position.set(0, 0, 0);
      virusGroup.add(warning);
      
      // Set up pulsing animation
      setInterval(() => {
        if (virusGroup.parent) {
          // Flash the sphere
          sphere.material.opacity = 0.4 + Math.random() * 0.6;
          sphere.scale.set(
            0.8 + Math.random() * 0.5,
            0.8 + Math.random() * 0.5,
            0.8 + Math.random() * 0.5
          );
          
          // Rotate the tetrahedrons randomly
          virusGroup.children.forEach((child, index) => {
            if (index < 3) { // Only affect the tetrahedrons
              child.rotation.x += (Math.random() - 0.5) * 0.2;
              child.rotation.z += (Math.random() - 0.5) * 0.2;
            }
          });
        }
      }, 100);
      
      obstacle = virusGroup;
      break;
  }
  
  // Position the obstacle
  obstacle.position.x = lanes[lane];
  obstacle.position.y = 0.5;
  obstacle.position.z = -100;
  obstacle.scale.set(1.2, 1.2, 1.2);
  
  scene.add(obstacle);
  obstacles.push(obstacle);
}

// Create collectible item - 80s icons
function createCollectible() {
  const lane = Math.floor(Math.random() * 3);
  const collectibleType = Math.floor(Math.random() * 4);
  
  let collectible;
  const colorIndex = Math.floor(Math.random() * neonColors.length);
  const itemColor = neonColors[colorIndex];
  
  switch (collectibleType) {
    case 0: // Cassette tape
      const cassetteGroup = new THREE.Group();
      
      // Create cassette body
      const tapeBody = new THREE.BoxGeometry(0.6, 0.1, 0.4);
      const tapeMaterial = new THREE.MeshBasicMaterial({ 
        color: itemColor,
        emissive: itemColor
      });
      const tape = new THREE.Mesh(tapeBody, tapeMaterial);
      cassetteGroup.add(tape);
      
      // Add cassette label
      const labelGeometry = new THREE.BoxGeometry(0.4, 0.01, 0.25);
      const labelMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
      const label = new THREE.Mesh(labelGeometry, labelMaterial);
      label.position.y = 0.06;
      cassetteGroup.add(label);
      
      // Add cassette holes
      const holeGeometry = new THREE.CylinderGeometry(0.03, 0.03, 0.12, 8);
      const holeMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
      
      const hole1 = new THREE.Mesh(holeGeometry, holeMaterial);
      hole1.rotation.z = Math.PI / 2;
      hole1.position.set(-0.15, 0, 0.2);
      cassetteGroup.add(hole1);
      
      const hole2 = new THREE.Mesh(holeGeometry, holeMaterial);
      hole2.rotation.z = Math.PI / 2;
      hole2.position.set(0.15, 0, 0.2);
      cassetteGroup.add(hole2);
      
      // Add neon glow
      const tapeLight = new THREE.PointLight(itemColor, 1, 2);
      tapeLight.position.set(0, 0, 0);
      cassetteGroup.add(tapeLight);
      
      collectible = cassetteGroup;
      break;
      
    case 1: // Retro game controller
      const controllerGroup = new THREE.Group();
      
      // Controller body
      const controllerGeometry = new THREE.BoxGeometry(0.6, 0.1, 0.4);
      const controllerMaterial = new THREE.MeshBasicMaterial({ 
        color: itemColor,
        emissive: itemColor
      });
      const controller = new THREE.Mesh(controllerGeometry, controllerMaterial);
      controllerGroup.add(controller);
      
      // D-pad
      const dpadBaseGeometry = new THREE.BoxGeometry(0.18, 0.02, 0.18);
      const dpadBaseMaterial = new THREE.MeshBasicMaterial({ color: 0x111111 });
      const dpadBase = new THREE.Mesh(dpadBaseGeometry, dpadBaseMaterial);
      dpadBase.position.set(-0.2, 0.06, 0);
      controllerGroup.add(dpadBase);
      
      // Action buttons
      const buttonGeometry = new THREE.CylinderGeometry(0.04, 0.04, 0.02, 16);
      const buttonMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
      
      const button1 = new THREE.Mesh(buttonGeometry, buttonMaterial);
      button1.rotation.x = Math.PI / 2;
      button1.position.set(0.15, 0.06, -0.05);
      controllerGroup.add(button1);
      
      const button2 = new THREE.Mesh(buttonGeometry, new THREE.MeshBasicMaterial({ color: 0x0000ff }));
      button2.rotation.x = Math.PI / 2;
      button2.position.set(0.25, 0.06, -0.05);
      controllerGroup.add(button2);
      
      // Add controller light
      const controllerLight = new THREE.PointLight(itemColor, 1, 2);
      controllerLight.position.set(0, 0.1, 0);
      controllerGroup.add(controllerLight);
      
      collectible = controllerGroup;
      break;
      
    case 2: // Vinyl record
      const recordGroup = new THREE.Group();
      
      // Main record disk
      const recordGeometry = new THREE.CylinderGeometry(0.3, 0.3, 0.02, 32);
      const recordMaterial = new THREE.MeshBasicMaterial({ color: 0x111111 });
      const record = new THREE.Mesh(recordGeometry, recordMaterial);
      record.rotation.x = Math.PI / 2;
      recordGroup.add(record);
      
      // Add record label in the center
      const labelRadius = 0.1;
      const recordLabelGeometry = new THREE.CylinderGeometry(labelRadius, labelRadius, 0.025, 32);
      const recordLabelMaterial = new THREE.MeshBasicMaterial({ color: itemColor });
      const recordLabel = new THREE.Mesh(recordLabelGeometry, recordLabelMaterial);
      recordLabel.rotation.x = Math.PI / 2;
      recordLabel.position.z = 0.003;
      recordGroup.add(recordLabel);
      
      // Add center hole
      const holeGeometry2 = new THREE.CylinderGeometry(0.02, 0.02, 0.03, 16);
      const holeMaterial2 = new THREE.MeshBasicMaterial({ color: 0x000000 });
      const hole = new THREE.Mesh(holeGeometry2, holeMaterial2);
      hole.rotation.x = Math.PI / 2;
      recordGroup.add(hole);
      
      // Add neon reflection/glow
      const recordLight = new THREE.PointLight(itemColor, 1.5, 3);
      recordLight.position.set(0, 0, 0);
      recordGroup.add(recordLight);
      
      collectible = recordGroup;
      break;
      
    case 3: // Holographic pyramid
      const pyramidGroup = new THREE.Group();
      
      // Create outer wireframe
      const pyramidGeometry = new THREE.TetrahedronGeometry(0.4, 0);
      const pyramidMaterial = new THREE.MeshBasicMaterial({ 
        color: itemColor,
        wireframe: true,
        transparent: true,
        opacity: 0.8
      });
      const pyramidWireframe = new THREE.Mesh(pyramidGeometry, pyramidMaterial);
      pyramidGroup.add(pyramidWireframe);
      
      // Create inner solid with holographic effect
      const innerGeometry = new THREE.TetrahedronGeometry(0.3, 0);
      const innerMaterial = new THREE.MeshBasicMaterial({ 
        color: 0xffffff,
        transparent: true,
        opacity: 0.3
      });
      const innerPyramid = new THREE.Mesh(innerGeometry, innerMaterial);
      pyramidGroup.add(innerPyramid);
      
      // Add strong glow light
      const pyramidLight = new THREE.PointLight(itemColor, 1.5, 3);
      pyramidLight.position.set(0, 0, 0);
      pyramidGroup.add(pyramidLight);
      
      collectible = pyramidGroup;
      
      // Add special animation function for this collectible
      collectible.userData = {
        animate: function(time) {
          // Rotate the wireframe and inner pyramid differently
          pyramidWireframe.rotation.y += 0.01;
          innerPyramid.rotation.y -= 0.005;
          innerPyramid.rotation.x += 0.003;
        }
      };
      break;
  }
  
  // Position the collectible
  collectible.position.x = lanes[lane];
  collectible.position.y = 0.5 + Math.sin(Date.now() * 0.003) * 0.2; // Floating effect
  collectible.position.z = -100 - Math.random() * 20;
  
  scene.add(collectible);
  collectibles.push(collectible);
}

// Handle window resize
function onWindowResize() {
  // Update camera aspect ratio
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  
  // Resize renderer
  renderer.setSize(window.innerWidth, window.innerHeight);
  
  // Re-position UI elements if needed
  if (window.innerHeight < 500) {
    // Adjust for small screens
    document.getElementById('instructions').style.display = 'none';
  } else {
    document.getElementById('instructions').style.display = 'block';
  }
}

// This function used to update score, but we've removed scoring
// Keeping an empty function to avoid breaking existing calls
function updateScore(newScore) {
  // Score tracking removed - purely for showing GitHub projects
}

// Camera shake effect (for obstacle collisions)
function shakeCamera(intensity = 0.5) {
  const originalPosition = camera.position.clone();
  const shakeDuration = 20; // frames
  let shakeFrame = 0;
  
  function doShake() {
    if (shakeFrame < shakeDuration) {
      // Calculate decreasing intensity
      const currentIntensity = intensity * (1 - shakeFrame / shakeDuration);
      
      // Apply random offset to camera
      camera.position.x = originalPosition.x + (Math.random() - 0.5) * currentIntensity;
      camera.position.y = originalPosition.y + (Math.random() - 0.5) * currentIntensity;
      
      shakeFrame++;
      requestAnimationFrame(doShake);
    } else {
      // Reset camera position after shake
      camera.position.copy(originalPosition);
    }
  }
  
  doShake();
}

// Check collisions
function checkCollisions() {
  // No obstacle collisions - only collectibles for repo display
  
  // Track if we're currently showing a repo to prevent overlapping displays
  if (!window.gameState) {
    window.gameState = {
      isShowingRepo: false,
      lastRepoShownTime: 0
    };
  }
  const currentTime = Date.now();
  const REPO_DISPLAY_COOLDOWN = 2000; // Minimum 2 seconds between repo displays

  // Check collectible collisions
  for (let i = collectibles.length - 1; i >= 0; i--) {
    const collectible = collectibles[i];
    
    // Check if collectible is too far behind
    if (collectible.position.z > 10) {
      scene.remove(collectible);
      collectibles.splice(i, 1);
      continue;
    }
    
    // Check for collectible pickup
    const distance = player.position.distanceTo(collectible.position);
    if (distance < playerSize + 0.7) {
      // Only show repo if enough time has passed since the last one
      const shouldShowRepo = !window.gameState.isShowingRepo && 
                             (currentTime - window.gameState.lastRepoShownTime > REPO_DISPLAY_COOLDOWN);
      
      // Create collection effect (potentially without showing repo)
      createCollectionEffect(collectible.position.x, collectible.position.y, collectible.position.z, shouldShowRepo);
      
      // If we're showing a repo, update our state
      if (shouldShowRepo) {
        window.gameState.isShowingRepo = true;
        window.gameState.lastRepoShownTime = currentTime;
        
        // Reset the flag after a delay to allow showing the next repo
        setTimeout(() => {
          window.gameState.isShowingRepo = false;
        }, REPO_DISPLAY_COOLDOWN);
      }
      
      // Remove collectible
      scene.remove(collectible);
      collectibles.splice(i, 1);
      
      // Occasionally flash grid for visual interest
      if (Math.random() < 0.2) { // 20% chance on collection
        flashGrid();
      }
    }
  }
}

// Create explosion effect when player hits obstacle (optimized)
function createExplosion(x, y, z) {
  const particleCount = 15; // Reduced by half for better performance
  const particles = [];
  
  // Reuse geometries and materials for better performance
  const particleGeometry = new THREE.BoxGeometry(0.1, 0.1, 0.1);
  const particleMaterial1 = new THREE.MeshBasicMaterial({
    color: 0xff0000,
    transparent: true,
    opacity: 1
  });
  const particleMaterial2 = new THREE.MeshBasicMaterial({
    color: 0xff00ff,
    transparent: true,
    opacity: 1
  });
  
  for (let i = 0; i < particleCount; i++) {
    const particle = new THREE.Mesh(
      particleGeometry,
      i % 2 === 0 ? particleMaterial1 : particleMaterial2
    );
    
    particle.position.set(x, y, z);
    particle.velocity = {
      x: (Math.random() - 0.5) * 0.2,
      y: (Math.random() - 0.5) * 0.2, 
      z: (Math.random() - 0.5) * 0.2
    };
    
    scene.add(particle);
    particles.push(particle);
  }
  
  // Animate particles
  const animateParticles = () => {
    // Always animate particles (removed gameOver check)
    particles.forEach(particle => {
      particle.position.x += particle.velocity.x;
      particle.position.y += particle.velocity.y;
      particle.position.z += particle.velocity.z;
      
      particle.material.opacity -= 0.02;
      
      if (particle.material.opacity <= 0) {
        scene.remove(particle);
      }
    });
    
    // Continue animation if particles exist
    if (particles.length > 0) {
      requestAnimationFrame(animateParticles);
    }
  };
  
  animateParticles();
}

// Create collection effect when player picks up collectible (optimized)
function createCollectionEffect(x, y, z, showRepo = true) {
  // Create expanding ring (simplified geometry for performance)
  const ringGeometry = new THREE.RingGeometry(0.1, 0.15, 16); // Reduced segments
  const ringMaterial = new THREE.MeshBasicMaterial({
    color: 0x00ffff,
    side: THREE.DoubleSide,
    transparent: true,
    opacity: 1
  });
  
  const ring = new THREE.Mesh(ringGeometry, ringMaterial);
  ring.position.set(x, y, z);
  ring.rotation.y = Math.PI / 2;
  scene.add(ring);
  
  // Create particles burst effect - fewer particles for better performance
  const particleCount = 6; // Further reduced for better performance
  const particles = [];
  
  // Reuse geometries and materials for better performance
  const particleGeometry = new THREE.BoxGeometry(0.1, 0.1, 0.1);
  const particleMaterial1 = new THREE.MeshBasicMaterial({
    color: 0x00ffff,
    transparent: true,
    opacity: 1
  });
  const particleMaterial2 = new THREE.MeshBasicMaterial({
    color: 0xff00ff,
    transparent: true,
    opacity: 1
  });
  
  for (let i = 0; i < particleCount; i++) {
    const particle = new THREE.Mesh(
      particleGeometry, 
      i % 2 === 0 ? particleMaterial1 : particleMaterial2
    );
    
    particle.position.set(x, y, z);
    particle.velocity = {
      x: (Math.random() - 0.5) * 0.1,
      y: (Math.random() - 0.5) * 0.1 + 0.05, // Slight upward bias
      z: (Math.random() - 0.5) * 0.1
    };
    
    scene.add(particle);
    particles.push(particle);
  }
  
  // Add point light flash (same as before)
  const pointLight = new THREE.PointLight(0xffffff, 2, 5);
  pointLight.position.set(x, y, z);
  scene.add(pointLight);
  
  // Display GitHub repo info if available AND if showRepo flag is true
  if (showRepo && githubRepos && githubRepos.length > 0) {
    // Get the next repository from the front of the array (newest repos first)
    // This ensures we're always showing the most recently updated repos first
    const repo = githubRepos[0];
    
    // Create the exploding text effect with the repository info
    createExplodingRepoText(new THREE.Vector3(x, y, z), repo);
    
    // Move this repo to the end of the array to cycle through them
    // This way we show all repos before repeating
    if (githubRepos.length > 1) {
      const usedRepo = githubRepos.shift(); // Remove from front
      githubRepos.push(usedRepo); // Add to end
    }
    
    // No automatic refresh on collection - using initial data only
  }
  
  // Animate expanding ring and particles
  let scale = 0.1;
  const animate = () => {
    if (scale < 3) {
      // Animate ring
      scale += 0.15;
      ring.scale.set(scale, scale, scale);
      ring.material.opacity = 1 - scale / 3;
      ring.rotation.z += 0.02;
      
      // Animate particles
      particles.forEach(particle => {
        particle.position.x += particle.velocity.x;
        particle.position.y += particle.velocity.y;
        particle.position.z += particle.velocity.z;
        particle.material.opacity -= 0.02;
        particle.rotation.x += 0.1;
        particle.rotation.y += 0.1;
      });
      
      // Fade out light
      pointLight.intensity = 2 * (1 - scale / 3);
      
      requestAnimationFrame(animate);
    } else {
      // Clean up
      scene.remove(ring);
      particles.forEach(particle => scene.remove(particle));
      scene.remove(pointLight);
    }
  };
  
  animate();
}

// Flash grid effect when leveling up
function flashGrid() {
  const originalColors = [0xff00ff, 0x00ffff];
  let flashCount = 0;
  
  const flashInterval = setInterval(() => {
    if (flashCount < 6) {
      if (flashCount % 2 === 0) {
        // Flash to white
        gridHelper.material[0].color.setHex(0xffffff);
        gridHelper.material[1].color.setHex(0xffffff);
      } else {
        // Flash back to original colors
        gridHelper.material[0].color.setHex(originalColors[0]);
        gridHelper.material[1].color.setHex(originalColors[1]);
      }
      flashCount++;
    } else {
      clearInterval(flashInterval);
    }
  }, 100);
}

// No game over functionality needed

// Start the game
function startGame() {
  gameStarted = true;
  gameOver = false; // Keep this for compatibility but don't use it
  document.getElementById('start-screen').classList.add('hidden');
  updateScore(0);
  
  // Start with a grid flash
  flashGrid();
  
  // Only create collectibles - no obstacles
  // Create more initial collectibles to increase chances of seeing repos
  for (let i = 0; i < 10; i++) {
    createCollectible();
    collectibles[i].position.z = -15 - (i * 7); // Position them at different distances
  }
  
  // Create an initial repo text display in the center to show the player what to expect
  setTimeout(() => {
    if (githubRepos && githubRepos.length > 0) {
      // Create a special intro display showing what to expect (just repo name)
      const center = new THREE.Vector3(0, 1.5, -5);
      const welcomeRepo = {
        name: "WELCOME - CATCH NEON SHAPES",
        language: "GitHub Projects",
        stars: 0,
        color: 0xffff00
      };
      createExplodingRepoText(center, welcomeRepo);
    }
  }, 1000); // Show intro message after a short delay
}

// Refresh the game - can be triggered manually if needed
function refreshGame() {
  // Reset basic game parameters but don't stop gameplay
  speed = 0.2;
  level = 1;
  
  // Clear obstacles and collectibles
  for (const obstacle of obstacles) {
    scene.remove(obstacle);
  }
  obstacles = [];
  
  for (const collectible of collectibles) {
    scene.remove(collectible);
  }
  collectibles = [];
  
  // Keep current text particles - they'll fade naturally
  
  // Reset player position to current lane
  player.position.set(lanes[currentLane], playerSize / 2, 0);
  player.rotation.set(0, 0, 0);
  
  // Reset score
  updateScore(0);
  
  // Flash grid for visual effect
  flashGrid();
  
  // Use existing repo data - no additional fetch
  if (githubRepos && githubRepos.length > 0) {
    console.log('Using existing GitHub repos:', githubRepos.length);
    
    // Show newest repo as an announcement
    setTimeout(() => {
      const newestRepo = githubRepos[0];
      const center = new THREE.Vector3(0, 2, -3);
      createExplodingRepoText(center, newestRepo);
    }, 500);
  }
  
  // Create new collectibles - more of them since they're the only interactive elements
  for (let i = 0; i < 10; i++) {
    createCollectible();
    collectibles[i].position.z = -15 - (i * 6); // Position them closer together
  }
}

// Animation loop
function animate() {
  try {
    animationId = requestAnimationFrame(animate);
    
    // Always animate grid and sun, even before game starts
    // Move and animate grid
    if (gridHelper) {
      gridHelper.position.z += gameStarted ? speed : 0.1;
      if (gridHelper.position.z > 0) {
        gridHelper.position.z = -1000;
      }
    }
    
    // Move the retro sun and stars
    if (sun) {
      sun.rotation.z += 0.005;
    }
  
    // Update exploding text particles
    for (let i = explodingTexts.length - 1; i >= 0; i--) {
      try {
        const textParticle = explodingTexts[i];
        if (!textParticle || !textParticle.update) {
          // Invalid particle, remove it
          console.warn('Invalid text particle found, removing');
          if (textParticle && textParticle.mesh) {
            scene.remove(textParticle.mesh);
          }
          explodingTexts.splice(i, 1);
          continue;
        }
        
        const isAlive = textParticle.update();
        
        if (!isAlive) {
          // Remove dead particles from scene and array
          if (textParticle.mesh) {
            scene.remove(textParticle.mesh);
          }
          explodingTexts.splice(i, 1);
        }
      } catch (err) {
        console.error('Error updating text particle:', err);
        // Remove problematic particle
        try {
          if (explodingTexts[i] && explodingTexts[i].mesh) {
            scene.remove(explodingTexts[i].mesh);
          }
        } catch (e) {
          // Ignore further errors in cleanup
        }
        explodingTexts.splice(i, 1);
      }
    }
    
    if (gameStarted) {
      // Move player to target lane if player exists
      if (player) {
        player.position.x += (lanes[currentLane] - player.position.x) * 0.1;
        
        // Rotate wheels or add hover effect
        if (player.children && player.children.length > 0) {
          player.children.forEach(child => {
            try {
              // Add slight bobbing motion to simulate hovering
              child.position.y = Math.sin(Date.now() * 0.005) * 0.03;
            } catch (e) {
              console.error('Error updating player child:', e);
            }
          });
        }
      }
      
      // Move obstacles with error handling
      for (let i = obstacles.length - 1; i >= 0; i--) {
        try {
          const obstacle = obstacles[i];
          obstacle.position.z += speed;
          
          // Different rotation effects based on obstacle type
          if (obstacle.children && obstacle.children[0] && obstacle.children[0].geometry) {
            // For group objects
            obstacle.rotation.z += 0.03;
          }
        } catch (err) {
          console.error('Error updating obstacle:', err);
          // Remove problematic obstacle
          if (obstacles[i]) {
            try {
              scene.remove(obstacles[i]);
            } catch (e) {
              // Ignore further errors
            }
            obstacles.splice(i, 1);
          }
        }
      }
      
      // Move collectibles with error handling
      for (let i = collectibles.length - 1; i >= 0; i--) {
        try {
          const collectible = collectibles[i];
          collectible.position.z += speed;
          
          // Check for special animation function
          if (collectible.userData && collectible.userData.animate) {
            collectible.userData.animate(Date.now());
          } else {
            // Different animation based on collectible type
            collectible.rotation.y += 0.02;
          }
          
          // Floating effect
          collectible.position.y = 0.5 + Math.sin(Date.now() * 0.002 + collectible.position.x) * 0.2;
        } catch (err) {
          console.error('Error updating collectible:', err);
          // Remove problematic collectible
          if (collectibles[i]) {
            try {
              scene.remove(collectibles[i]);
            } catch (e) {
              // Ignore further errors
            }
            collectibles.splice(i, 1);
          }
        }
      }
      
      // Only create collectibles - no obstacles
      try {
        // Higher chance of collectibles to ensure a steady stream
        if (Math.random() < 0.03) {
          createCollectible();
        }
        
        // Check collisions
        checkCollisions();
      } catch (err) {
        console.error('Error in game logic:', err);
      }
      
      // No refresh in animation loop - using initial data only
    }
    
    // Render scene
    if (renderer && scene && camera) {
      renderer.render(scene, camera);
    }
  } catch (err) {
    console.error('Critical error in animation loop:', err);
    // Try to recover by requesting next frame
    requestAnimationFrame(animate);
  }
}

// Initialize the game when the page loads with safety checks
document.addEventListener('DOMContentLoaded', function() {
  console.log('DOM content loaded, starting initialization...');
  
  // Check for THREE before trying to initialize
  if (typeof THREE === 'undefined') {
    console.error('THREE is not defined! Attempting to load Three.js directly...');
    
    // Try to load Three.js dynamically
    const script = document.createElement('script');
    script.src = 'https://cdn.jsdelivr.net/npm/three@0.150.1/build/three.min.js'; // Use newer version
    script.onload = function() {
      console.log('Three.js loaded successfully!');
      // Initialize game after loading
      try {
        init();
        console.log('Game initialized successfully');
      } catch (err) {
        console.error('Error during game initialization:', err);
        alert('Error initializing game. Please check the console for details.');
      }
    };
    script.onerror = function() {
      console.error('Failed to load Three.js dynamically');
      alert('Could not load Three.js library. Please refresh the page or try a different browser.');
    };
    document.head.appendChild(script);
  } else {
    // THREE is available, initialize normally
    console.log('THREE is already defined, initializing game...');
    try {
      init();
      console.log('Game initialized successfully');
    } catch (err) {
      console.error('Error during game initialization:', err);
      alert('Error initializing game. Please check the console for details.');
    }
  }
});

// Simplified global handler for spacebar - capture at window level
window.addEventListener('keydown', function(event) {
  // Handle the space key for controlling the game
  if (event.key === ' ' || event.code === 'Space') {
    // Prevent page scrolling
    event.preventDefault();
    
    // Handle game state
    if (!gameStarted) {
      startGame();
    }
  }
}, false);
</script>