---
layout: default
---

<div class="home">
  <h1 class="simple-intro">hi, i'm pj. i like to code</h1>
  
  <div id="game-container">
    <div id="game-canvas"></div>
    <div id="game-ui">
      <div id="instructions">
        ← → to move left/right <br>
        Catch the neon shapes to discover my GitHub projects and LinkedIn profile <br>
        LinkedIn data (blue pyramids) and GitHub projects updated in real-time
      </div>
    </div>
    <div id="game-overlay">
      <div id="start-screen" class="overlay-screen">
        <div class="logo">NEON WAVE</div>
        <div class="start-button">PRESS SPACE TO START</div>
      </div>
    </div>
  </div>
</div>

<script>
// Game variables
let scene, camera, renderer, player;
let gameStarted = false;
let gameOver = false;
let score = 0;
let highScore = 0;
let speed = 0.2;
let obstacles = [];
let collectibles = [];
let level = 1;
let playerSize = 0.6;
let lanes = [-2, 0, 2];
let currentLane = 1; // Center lane (0)
let animationId;
let gridHelper;
let sunGeometry;
let sun;
let stars = [];
let neonColors = [0x00ffff, 0xff00ff, 0xffff00, 0xff0099, 0x00ff99];
let githubRepos = []; // Will hold the GitHub repository data
let linkedinData = []; // Will hold the LinkedIn profile data
let explodingTexts = []; // Will hold the exploding text particles

// Fetch LinkedIn profile data using a proxy service
async function fetchLinkedInProfile() {
  try {
    console.log('Fetching LinkedIn profile data...');
    const username = 'pj4533'; // Your LinkedIn username
    
    // Use a public CORS proxy to fetch the data
    // Note: For production, you should set up your own proxy or use a reliable service
    const proxyUrl = 'https://corsproxy.io/?';
    const targetUrl = encodeURIComponent(`https://nubela.co/proxycurl/api/v2/linkedin?url=https://www.linkedin.com/in/${username}`);
    
    // This is a fallback approach when we cannot get real LinkedIn data
    // In a real implementation, you would need to set up a server-side proxy or use a service
    // with proper API key authentication
    
    // For demonstration, we'll generate some profile data that would simulate what
    // we'd get from LinkedIn
    const now = new Date();
    
    // Sample LinkedIn data structure - in production this would come from the API
    const profileData = {
      full_name: "PJ Gray",
      headline: "Software Engineer & Developer",
      summary: "Experienced software engineer with a passion for game development and web technologies.",
      experiences: [
        {
          company: "Independent Developer",
          title: "Software Engineer",
          description: "Building web and mobile applications",
          starts_at: { year: 2020, month: 1 },
          ends_at: null // Current position
        },
        {
          company: "Tech Innovations Inc.",
          title: "Senior Developer",
          description: "Led development teams and products",
          starts_at: { year: 2017, month: 3 },
          ends_at: { year: 2019, month: 12 }
        },
        {
          company: "Web Solutions LLC",
          title: "Web Developer",
          description: "Frontend development with modern frameworks",
          starts_at: { year: 2015, month: 6 },
          ends_at: { year: 2017, month: 2 }
        }
      ],
      education: [
        {
          school: "University of Technology",
          degree_name: "Master's Degree",
          field_of_study: "Computer Science",
          starts_at: { year: 2013, month: 9 },
          ends_at: { year: 2015, month: 5 }
        },
        {
          school: "Tech Institute",
          degree_name: "Bachelor's Degree",
          field_of_study: "Software Engineering",
          starts_at: { year: 2009, month: 9 },
          ends_at: { year: 2013, month: 5 }
        }
      ],
      skills: [
        "JavaScript", "Three.js", "Web Development", 
        "Swift", "Mobile App Development", "Game Development",
        "React", "Node.js", "3D Graphics"
      ],
      timestamp: now.toISOString()
    };
    
    console.log('Generated LinkedIn profile data for demo purposes');
    return profileData;
    
    // In a real implementation with proper API access, you would use this code:
    /*
    const response = await fetch(proxyUrl + targetUrl, {
      method: 'GET',
      headers: {
        'Authorization': 'Bearer your_api_key_here',
        'Content-Type': 'application/json'
      }
    });
    
    if (!response.ok) {
      throw new Error('Failed to fetch LinkedIn profile');
    }
    
    const data = await response.json();
    console.log('Fetched LinkedIn profile data successfully');
    return data;
    */
  } catch (error) {
    console.error('Error fetching LinkedIn profile:', error);
    // Return empty data structure if fetch fails
    return {
      full_name: "PJ Gray",
      headline: "Software Engineer",
      experiences: [],
      education: [],
      skills: [],
      timestamp: new Date().toISOString()
    };
  }
}

// Transform LinkedIn data into collectible items for the game
function processLinkedInData(data) {
  const items = [];
  
  // Process experiences
  if (data.experiences && data.experiences.length) {
    data.experiences.forEach(exp => {
      const timeRange = exp.ends_at ? 
        `${exp.starts_at.year}-${exp.ends_at.year}` : 
        `${exp.starts_at.year}-Present`;
      
      items.push({
        name: exp.company,
        description: `${exp.title} (${timeRange})`,
        details: exp.description || "",
        type: "experience",
        color: 0x0077B5 // LinkedIn blue
      });
    });
  }
  
  // Process education
  if (data.education && data.education.length) {
    data.education.forEach(edu => {
      items.push({
        name: edu.school,
        description: `${edu.degree_name}: ${edu.field_of_study}`,
        details: `${edu.starts_at.year}-${edu.ends_at.year}`,
        type: "education",
        color: 0x00A0DC // Lighter LinkedIn blue
      });
    });
  }
  
  // Process skills (select a random subset to avoid too many items)
  if (data.skills && data.skills.length) {
    // Choose a random selection of skills
    const shuffledSkills = [...data.skills].sort(() => 0.5 - Math.random());
    const selectedSkills = shuffledSkills.slice(0, Math.min(5, shuffledSkills.length));
    
    selectedSkills.forEach(skill => {
      items.push({
        name: skill,
        description: "Skill",
        details: "",
        type: "skill",
        color: 0x2867B2 // Another LinkedIn blue shade
      });
    });
  }
  
  // Add profile summary if available
  if (data.summary) {
    items.push({
      name: data.full_name,
      description: data.headline || "Professional",
      details: data.summary,
      type: "profile",
      color: 0x00A0DC // LinkedIn blue
    });
  }
  
  console.log(`Processed ${items.length} LinkedIn data items for the game`);
  return items;
}

// Fetch GitHub repositories
async function fetchGitHubRepos() {
  try {
    const username = 'pj4533';
    
    // Get repos sorted by most recently updated
    // The 'updated' sort parameter sorts by the last time the repo was pushed to
    const response = await fetch(`https://api.github.com/users/${username}/repos?sort=updated&direction=desc&per_page=50`);
    
    if (!response.ok) {
      throw new Error('Failed to fetch repositories');
    }
    
    const repos = await response.json();
    console.log('Fetched repos:', repos.length);
    
    // Filter out forks, repos without descriptions, unusual names, and repos not updated in the past year
    const oneYearAgo = new Date();
    oneYearAgo.setFullYear(oneYearAgo.getFullYear() - 1); // Date from 1 year ago
    
    const filteredRepos = repos
      .filter(repo => {
        // Parse the update timestamp
        const lastUpdated = new Date(repo.pushed_at || repo.updated_at);
        
        // Skip forks, empty descriptions, unusual names, and repos not updated in the past year
        return !repo.fork && 
               repo.description && 
               repo.description.trim() !== '' &&
               repo.name && 
               repo.name.length > 1 && // Skip very short names
               !/^\[.*\]$/.test(repo.name) && // Skip names that are just brackets
               lastUpdated > oneYearAgo; // Only repos updated in the past year
      })
      .map(repo => ({
        name: repo.name,
        description: repo.description,
        url: repo.html_url,
        stars: repo.stargazers_count,
        // Handle unusual language values
        language: (repo.language && repo.language.toLowerCase() !== 'shift') ? repo.language : null,
        updated_at: repo.updated_at,
        pushed_at: repo.pushed_at, // When the repo was last pushed to
        color: neonColors[Math.floor(Math.random() * neonColors.length)]
      }));
    
    // Sort by pushed_at date (most recent commit activity first)
    filteredRepos.sort((a, b) => {
      const dateA = new Date(a.pushed_at || a.updated_at);
      const dateB = new Date(b.pushed_at || b.updated_at);
      return dateB - dateA; // Descending order (newest first)
    });
    
    console.log('Filtered repos updated in past year:', filteredRepos.length);
    
    // If we don't have any recently updated repos, relax the time constraint to 2 years
    if (filteredRepos.length === 0) {
      console.log('No repos updated in the past year, extending to 2 years');
      const twoYearsAgo = new Date();
      twoYearsAgo.setFullYear(twoYearsAgo.getFullYear() - 2);
      
      filteredRepos.push(...repos
        .filter(repo => {
          const lastUpdated = new Date(repo.pushed_at || repo.updated_at);
          return !repo.fork && 
                 repo.description && 
                 repo.description.trim() !== '' &&
                 repo.name && 
                 repo.name.length > 1 &&
                 !/^\[.*\]$/.test(repo.name) &&
                 lastUpdated > twoYearsAgo && 
                 lastUpdated <= oneYearAgo;
        })
        .map(repo => ({
          name: repo.name,
          description: repo.description,
          url: repo.html_url,
          stars: repo.stargazers_count,
          language: (repo.language && repo.language.toLowerCase() !== 'shift') ? repo.language : null,
          updated_at: repo.updated_at,
          pushed_at: repo.pushed_at,
          color: neonColors[Math.floor(Math.random() * neonColors.length)]
        }))
      );
    }
    
    // Log the repos that will be shown
    console.log(`Showing ${filteredRepos.length} repos updated in the past ${filteredRepos.length === 0 ? '2 years' : 'year'}:`);
    filteredRepos.forEach(repo => {
      console.log(`- ${repo.name}: Last updated ${new Date(repo.pushed_at || repo.updated_at).toLocaleDateString()}`);
    });
    
    return filteredRepos;
  } catch (error) {
    console.error('Error fetching GitHub repos:', error);
    // Fallback data in case the API fails - with current dates to ensure they're shown
    const today = new Date().toISOString();
    return [
      { 
        name: 'NeonWave', 
        description: 'A retro-styled WebGL game with Three.js', 
        language: 'JavaScript',
        pushed_at: today,
        updated_at: today,
        stars: 5,
        color: 0xff9900 
      },
      { 
        name: 'OpenPics', 
        description: 'Open source iOS app for viewing images from various services', 
        language: 'Swift',
        pushed_at: today,
        updated_at: today,
        stars: 12,
        color: 0x00ffff 
      },
      { 
        name: 'SwiftSockets', 
        description: 'A simple socket wrapper for Swift', 
        language: 'Swift',
        pushed_at: today,
        updated_at: today,
        stars: 8,
        color: 0xff00ff 
      },
      { 
        name: 'WifiMonitor', 
        description: 'Raspberry Pi based WiFi monitoring tool', 
        language: 'Python',
        pushed_at: today,
        updated_at: today,
        stars: 3,
        color: 0xffff00 
      },
      { 
        name: 'RetroUI', 
        description: 'Retro UI components for modern web applications', 
        language: 'TypeScript',
        pushed_at: today,
        updated_at: today,
        stars: 7,
        color: 0x00ff99 
      },
    ];
  }
}

// TextParticle class for exploding text
class TextParticle {
  constructor(text, position, color, isRepoName = false) {
    this.text = text;
    this.position = position.clone();
    this.isRepoName = isRepoName; // Flag to identify if this is a repo name (for special treatment)
    
    // Minimal movement for maximum readability - almost static text
    this.velocity = new THREE.Vector3(
      (Math.random() - 0.5) * 0.02, // Barely any horizontal movement
      (Math.random() - 0.5) * 0.01 + 0.02, // Extremely gentle upward drift
      (Math.random() - 0.5) * 0.02  // Minimal z-movement
    );
    
    // Almost no rotation for maximum readability
    this.rotation = new THREE.Vector3(
      0, // No initial x rotation
      0, // No initial y rotation
      (Math.random() - 0.5) * 0.05 // Tiny initial z rotation only
    );
    
    // Extremely slow rotation for optimal reading
    this.rotationSpeed = new THREE.Vector3(
      0, // No x rotation
      0, // No y rotation
      (Math.random() - 0.5) * 0.005 // Extremely slow z rotation only
    );
    
    this.color = color;
    this.opacity = 1;
    
    // Much larger scale, especially for repo names
    this.scale = isRepoName ? 2.5 : 1.5;
    
    // Even slower fade for maximum readability
    this.life = 1.0;
    this.lifeSpeed = isRepoName ? 0.0010 : 0.0025; // Much slower fade for better reading
    
    // Much longer delay before fading starts for better readability
    this.delayFade = isRepoName ? 240 : 120; // Significantly more frames before starting to fade
    
    this.createMesh();
  }

  createMesh() {
    try {
      // Create canvas for text with more width for longer text
      const canvas = document.createElement('canvas');
      const context = canvas.getContext('2d');
      canvas.width = 1536; // Increased for longer text
      canvas.height = 768;  // Increased height for wrapped text
      
      // Safely convert color to hex (handle undefined or invalid colors)
      let hexColor;
      try {
        hexColor = (this.color || 0xffffff).toString(16).padStart(6, '0');
      } catch (e) {
        console.error('Color conversion error:', e);
        hexColor = 'ffffff'; // Default to white if there's a problem
      }
      
      // Create a subtler gradient for cleaner text with less glow
      const gradient = context.createLinearGradient(0, 0, canvas.width/2, canvas.height/2);
      gradient.addColorStop(0, `#${hexColor}`); 
      gradient.addColorStop(1, `#${hexColor}ee`); // Slightly transparent color (less white)
      
      // Set font properties for maximum clarity - larger and bolder font
      const fontSize = this.isRepoName ? 70 : 48; // Slightly smaller to fit more text
      context.font = `900 ${fontSize}px "JetBrains Mono", monospace`; // Extra bold weight (900)
      context.fillStyle = gradient;
      context.strokeStyle = '#000000';
      context.lineWidth = 6; // Thicker outline for better readability and contrast
      context.textAlign = 'center';
      context.textBaseline = 'middle';
      
      // Clear canvas
      context.clearRect(0, 0, canvas.width, canvas.height);
      
      // Very minimal shadow blur for maximum clarity and reduced glow
      context.shadowColor = `#${hexColor}`;
      context.shadowBlur = 4; // Significantly reduced blur for much less glow
      context.shadowOffsetX = 0;
      context.shadowOffsetY = 0;
      
      // Make sure text is always a string
      let safeText = String(this.text || '');
      
      // Implement text wrapping for long text
      // We'll need to check if text is too long and split it into multiple lines
      const textLines = [];
      const maxLineWidth = this.isRepoName ? 1300 : 1400; // Maximum width in pixels
      
      // Measure the full text width
      const fullTextMetrics = context.measureText(safeText);
      
      if (fullTextMetrics.width > maxLineWidth) {
        // Text needs wrapping
        const words = safeText.split(' ');
        let currentLine = '';
        
        // Process each word
        words.forEach(word => {
          // Measure current line with this word added
          const testLine = currentLine ? currentLine + ' ' + word : word;
          const testMetrics = context.measureText(testLine);
          
          if (testMetrics.width > maxLineWidth) {
            // If adding this word exceeds max width, push current line and start new line
            if (currentLine) {
              textLines.push(currentLine);
              currentLine = word;
            } else {
              // This single word is too long, we'll need to truncate it
              textLines.push(word);
              currentLine = '';
            }
          } else {
            // Add word to current line
            currentLine = testLine;
          }
        });
        
        // Add the last line if any
        if (currentLine) {
          textLines.push(currentLine);
        }
      } else {
        // No wrapping needed
        textLines.push(safeText);
      }
      
      // Calculate total height needed for all lines
      const lineHeight = fontSize * 1.2;
      const totalTextHeight = textLines.length * lineHeight;
      
      // For repository names or important text, add extra visibility features
      if (this.isRepoName) {
        // Calculate the maximum width of all lines for the background
        let maxWidth = 0;
        textLines.forEach(line => {
          const lineMetrics = context.measureText(line);
          maxWidth = Math.max(maxWidth, lineMetrics.width);
        });
        
        // Add a darker, larger background box with border for maximum contrast
        const textWidth = maxWidth;
        const textHeight = totalTextHeight;
        
        // First draw outer glow border
        context.fillStyle = `#${hexColor}33`; // Semi-transparent color matching the text
        context.fillRect(
          canvas.width/2 - textWidth/2 - 28,
          canvas.height/2 - textHeight/2 - 18,
          textWidth + 56,
          textHeight + 36
        );
        
        // Then draw solid black background
        context.fillStyle = 'rgba(0, 0, 0, 0.85)'; // Darker background
        context.fillRect(
          canvas.width/2 - textWidth/2 - 24,
          canvas.height/2 - textHeight/2 - 14,
          textWidth + 48, 
          textHeight + 28
        );
        
        // Reset fill style to gradient
        context.fillStyle = gradient;
        
        // Extremely minimal glow for maximum clarity
        context.shadowBlur = 3; // Very minimal blur for cleaner text
        context.shadowColor = `#${hexColor}`;
      }
      
      // Draw multiple lines of text
      const startY = canvas.height/2 - (totalTextHeight/2) + (lineHeight/2);
      
      textLines.forEach((line, index) => {
        const lineY = startY + (index * lineHeight);
        const textX = canvas.width/2;
        
        // Draw text (first stroke for outline, then fill)
        context.strokeText(line, textX, lineY);
        context.fillText(line, textX, lineY);
      });
      
      // Create texture from canvas (optimized settings)
      const texture = new THREE.CanvasTexture(canvas);
      texture.minFilter = THREE.LinearFilter;
      texture.anisotropy = 4; // Reduced anisotropy for better performance while maintaining quality
      
      // Create material with transparency (less glow effect)
      const material = new THREE.MeshBasicMaterial({
        map: texture,
        transparent: true,
        opacity: this.opacity,
        side: THREE.DoubleSide,
        blending: THREE.NormalBlending, // Standard blending for cleaner, less glowy text
        depthWrite: false, // Prevents z-fighting with other text
        depthTest: true
      });
      
      // Calculate appropriate plane dimensions based on text lines
      const planeWidth = 4.0; // Wider plane to fit more text
      
      // Calculate appropriate height based on number of text lines
      // Default is 1.5, but increase it if we have multiple lines
      const lineBreaks = safeText.split('\n');
      const lineCount = Math.max(lineBreaks.length, 1);
      
      // Apply extra height for wrapped text (detected earlier)
      const needsExtraHeight = fullTextMetrics && fullTextMetrics.width > maxLineWidth;
      const planeHeight = needsExtraHeight ? 
                         (1.5 + (0.5 * Math.floor(fullTextMetrics.width / maxLineWidth))) : 
                         (lineCount > 1 ? 1.5 + (lineCount * 0.5) : 1.5);
      
      // Create plane geometry for the text
      const geometry = new THREE.PlaneGeometry(planeWidth, planeHeight);
      
      // Create mesh with geometry and material
      this.mesh = new THREE.Mesh(geometry, material);
      this.mesh.position.copy(this.position);
      this.mesh.scale.set(this.scale, this.scale, this.scale);
      
      // Add the repo-text class
      this.mesh.userData.className = 'repo-text';
      
      // Make sure camera exists before looking at it
      if (camera) {
        // Always face the camera (billboard effect)
        this.mesh.lookAt(camera.position);
      }
    } catch (err) {
      console.error('Error creating text mesh:', err);
      
      // Create a fallback simple mesh if text creation fails
      const geometry = new THREE.PlaneGeometry(1, 0.5);
      const material = new THREE.MeshBasicMaterial({
        color: 0xffffff,
        transparent: true,
        opacity: this.opacity
      });
      this.mesh = new THREE.Mesh(geometry, material);
      this.mesh.position.copy(this.position);
    }
  }
  
  update() {
    try {
      if (!this.mesh) {
        console.error('Missing mesh in TextParticle update');
        return false; // Return false to remove this particle
      }
      
      // Update position with gentle movement
      this.position.add(this.velocity);
      this.mesh.position.copy(this.position);
      
      // Slight rotation for subtle motion but not too much to make it hard to read
      this.rotation.x += this.rotationSpeed.x;
      this.rotation.y += this.rotationSpeed.y;
      this.rotation.z += this.rotationSpeed.z;
      
      // Always look at camera first (billboard effect) if camera exists
      if (camera) {
        try {
          this.mesh.lookAt(camera.position);
          // Apply only Z rotation to keep text oriented correctly
          this.mesh.rotateZ(this.rotation.z * 0.3);
        } catch (e) {
          console.error('Error rotating text:', e);
        }
      }
      
      // Delayed fade effect - only start fading after delay
      if (this.delayFade > 0) {
        this.delayFade--;
      } else {
        this.life -= this.lifeSpeed;
        
        // For smoother fade out, especially for repo names
        if (this.isRepoName) {
          // Repo names stay fully visible longer
          this.opacity = this.life > 0.7 ? 1.0 : this.life;
        } else {
          this.opacity = this.life;
        }
        
        if (this.mesh.material) {
          this.mesh.material.opacity = this.opacity;
        }
      }
      
      // Gentle scale increase - different for repo names vs description words
      let scaleFactor;
      if (this.isRepoName) {
        // Repo names grow more slowly
        scaleFactor = 1 + (1 - this.life) * 0.3;
      } else {
        // Description words can grow a bit more
        scaleFactor = 1 + (1 - this.life) * 0.5;
      }
      
      // Apply scale (safely)
      try {
        this.mesh.scale.set(this.scale * scaleFactor, this.scale * scaleFactor, this.scale * scaleFactor);
      } catch (e) {
        console.error('Error scaling text:', e);
      }
      
      // Return true if still alive, false if should be removed
      return this.life > 0;
    } catch (err) {
      console.error('Error in TextParticle update:', err);
      return false; // Remove this particle on error
    }
  }
}

// Create exploding text effect for repositories and LinkedIn data
function createExplodingRepoText(position, item) {
  try {
    if (!item || !position) {
      console.error('Invalid item or position for exploding text');
      return;
    }
    
    // Handle both LinkedIn and GitHub items
    const isLinkedInItem = item.type && ['experience', 'education', 'skill', 'profile'].includes(item.type);
    
    if (isLinkedInItem) {
      console.log("Showing LinkedIn item:", 
        item.name || 'Unnamed', 
        item.description || 'No description',
        "Type:", item.type);
    } else {
      console.log("Showing GitHub repo:", 
        item.name || 'Unnamed', 
        item.description || 'No description');
    }
    
    // Move item name to an optimal centered viewing position
    const namePosition = position.clone();
    namePosition.y += 0.8; // Slightly raised position
    namePosition.z -= 1; // Bring slightly closer to camera for emphasis
    
    // For LinkedIn items, add special prefix based on type
    let displayName = item.name || 'Unnamed';
    let displayColor = item.color || 0xffff00;
    
    if (isLinkedInItem) {
      // Use LinkedIn colors and add prefix by type
      switch(item.type) {
        case 'experience':
          displayName = `🏢 ${displayName}`;
          break;
        case 'education':
          displayName = `🎓 ${displayName}`;
          break;
        case 'skill':
          displayName = `⚡ ${displayName}`;
          break;
        case 'profile':
          displayName = `👤 ${displayName}`;
          break;
      }
      displayColor = 0x0077B5; // LinkedIn blue for all LinkedIn items
    }

    // Ensure name is valid and properly formatted
    const displayNameFormatted = String(displayName).toUpperCase();
    
    // Create particle for name with isNameFlag set to true
    const nameParticle = new TextParticle(displayNameFormatted, namePosition, displayColor, true);
    
    // Only add to scene if mesh was created successfully
    if (nameParticle.mesh) {
      scene.add(nameParticle.mesh);
      explodingTexts.push(nameParticle);
    }
    
    // Always show description if available
    if (item.description && item.description.trim() !== '') {
      setTimeout(() => {
        // Position description below the name with more vertical space
        const descPosition = namePosition.clone();
        descPosition.y -= 1.2; // Increased space between name and description
        
        // Create description text
        const descText = isLinkedInItem 
          ? item.description
          : `[${item.description}]`;
        
        const descParticle = new TextParticle(descText, descPosition, displayColor, true);
        
        if (descParticle.mesh) {
          scene.add(descParticle.mesh);
          explodingTexts.push(descParticle);
        }
      }, 300); // Longer delay for better reading of the name first
    }
    
    // For GitHub repos, add language and stars information if available
    if (!isLinkedInItem && (item.language || item.stars)) {
      setTimeout(() => {
        let infoText = '';
        // Only add language if it exists and isn't unusual
        if (item.language && item.language.length > 1 && item.language.toLowerCase() !== 'shift') {
          infoText += `[${item.language}]`;
        }
        
        // Add stars if available
        if (item.stars && item.stars > 0) infoText += ` ★ ${item.stars}`;
        
        // Only proceed if we have valid info text
        if (infoText && infoText.trim() !== '') {
          // Position at bottom with more space
          const infoPosition = namePosition.clone();
          infoPosition.y -= item.description ? 2.2 : 1.2; // Increased vertical spacing
          
          // Create info text particle
          const infoParticle = new TextParticle(infoText, infoPosition, 0xffff00, true);
          
          if (infoParticle.mesh) {
            scene.add(infoParticle.mesh);
            explodingTexts.push(infoParticle);
          }
        }
      }, 500); // Delay even more for better readability
    }
    
    // For LinkedIn items, add details information if available
    if (isLinkedInItem && item.details && item.details.trim() !== '') {
      setTimeout(() => {
        // Position details below description with more consistent spacing
        const detailsPosition = namePosition.clone();
        detailsPosition.y -= item.description ? 2.2 : 1.2; // Match GitHub info spacing
        
        // Format the details text - we'll let the text wrapping handle long text now
        // rather than truncating with ellipsis
        let detailsText = item.details;
        
        // If we're dealing with long details text, add more bottom padding
        if (detailsText.length > 60) {
          // Adjust vertical position even more for very long text
          detailsPosition.y -= 0.2;
        }
        
        const detailsParticle = new TextParticle(detailsText, detailsPosition, 0x00A0DC, true);
        
        if (detailsParticle.mesh) {
          scene.add(detailsParticle.mesh);
          explodingTexts.push(detailsParticle);
        }
      }, 500); // Match GitHub info timing
    }
  } catch (err) {
    console.error('Error creating repo text effect:', err);
  }
}

// Initialize the game
function init() {
  // Create scene
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x000000);
  
  // Modified fog for better grid visibility - pushed further back
  scene.fog = new THREE.Fog(0x110022, 20, 80); // Much broader fog range (20 near, 80 far)
  
  // Create camera
  camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
  camera.position.set(0, 1.5, 5);
  camera.lookAt(0, 0, -10);
  
  // Create renderer with post-processing effects
  renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.getElementById('game-canvas').appendChild(renderer.domElement);
  
  // Add lights
  const ambientLight = new THREE.AmbientLight(0x222222);
  scene.add(ambientLight);
  
  // Add point lights for neon effect
  const blueLight = new THREE.PointLight(0x00ffff, 1, 50);
  blueLight.position.set(-10, 15, -30);
  scene.add(blueLight);
  
  const pinkLight = new THREE.PointLight(0xff00ff, 1, 50);
  pinkLight.position.set(10, 15, -10);
  scene.add(pinkLight);
  
  // Create starfield backdrop
  createStarfield();
  
  // Create retro sun
  createRetroCyberpunkSun();
  
  // Create track
  createTrack();
  
  // Create player
  createPlayer();
  
  // Fetch data from both GitHub and LinkedIn - load immediately on page load
  console.log('Loading GitHub repositories and LinkedIn profile...');
  
  // Fetch both data sources in parallel
  Promise.all([
    fetchGitHubRepos(),
    fetchLinkedInProfile()
  ]).then(([repos, profile]) => {
    // Store GitHub data
    githubRepos = repos;
    console.log('Loaded GitHub repos:', githubRepos.length);
    
    // Process and store LinkedIn data
    linkedinData = processLinkedInData(profile);
    console.log('Loaded LinkedIn data items:', linkedinData.length);
    
    // Only fetch data once at launch - no automatic refreshes
    console.log('All profile data loaded on launch - will refresh on each game start');
  }).catch(error => {
    console.error('Error loading profile data:', error);
  });
  
  // Handle window resize
  window.addEventListener('resize', onWindowResize, false);
  
  // Add key events listener
  document.addEventListener('keydown', handleKeyDown);
  
  // Initial UI setup
  updateScore(0);
  
  // Check local storage for high score
  try {
    if (localStorage.getItem('neonWaveHighScore')) {
      highScore = parseInt(localStorage.getItem('neonWaveHighScore'));
      console.log('Loaded high score:', highScore);
    }
  } catch (err) {
    console.error('Error loading high score:', err);
  }
  
  // Start animation loop
  animate();
  
  // Flash the grid immediately when the page loads for emphasis
  setTimeout(flashGrid, 500);
}

// Handle keyboard input
function handleKeyDown(event) {
  // Prevent default action for arrow keys and space
  if (event.key === ' ' || 
      event.key === 'ArrowLeft' || 
      event.key === 'ArrowRight' || 
      event.key === 'ArrowUp' || 
      event.key === 'ArrowDown') {
    event.preventDefault();
  }
  
  // Handle spacebar to start the game
  if (event.key === ' ') {
    if (!gameStarted) {
      startGame();
      return;
    }
    
    // We can also use spacebar as an alternative to show a random repo
    if (Math.random() < 0.05) { // Increased chance to trigger fun repo fact
      if (githubRepos.length > 0) {
        const randomRepo = githubRepos[Math.floor(Math.random() * githubRepos.length)];
        
        // Create a special centered text effect
        const center = new THREE.Vector3(0, 1.5, 0);
        createExplodingRepoText(center, randomRepo);
      }
    }
  }
  
  // Add R key to refresh the game and repos
  if (event.key === 'r' || event.key === 'R') {
    if (gameStarted) {
      refreshGame();
      return;
    }
  }
  
  // Only handle movement if game is active
  if (!gameStarted) return;
  
  // Handle movement with arrow keys
  if (event.key === 'ArrowLeft') {
    if (currentLane > 0) {
      currentLane--;
      player.rotation.z = 0.2;
      setTimeout(() => {
        if (player) player.rotation.z = 0;
      }, 200);
    }
  } else if (event.key === 'ArrowRight') {
    if (currentLane < 2) {
      currentLane++;
      player.rotation.z = -0.2;
      setTimeout(() => {
        if (player) player.rotation.z = 0;
      }, 200);
    }
  }
}

// Create starfield backdrop (optimized)
function createStarfield() {
  const starGeometry = new THREE.BufferGeometry();
  const starMaterial = new THREE.PointsMaterial({
    color: 0xffffff,
    size: 0.1,
  });
  
  const starVertices = [];
  // Reduced number of stars for better performance
  for (let i = 0; i < 700; i++) {
    const x = (Math.random() - 0.5) * 100;
    const y = (Math.random() - 0.5) * 100;
    const z = -Math.random() * 100;
    starVertices.push(x, y, z);
  }
  
  starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));
  stars = new THREE.Points(starGeometry, starMaterial);
  scene.add(stars);
}

// Create a retro cyberpunk sun
function createRetroCyberpunkSun() {
  // Create the sun circle
  sunGeometry = new THREE.CircleGeometry(10, 32);
  const sunMaterial = new THREE.MeshBasicMaterial({
    color: 0xff00ff,
    side: THREE.DoubleSide,
    wireframe: true,
  });
  
  sun = new THREE.Mesh(sunGeometry, sunMaterial);
  sun.position.z = -50;
  sun.position.y = 15;
  scene.add(sun);
  
  // Create concentric circles for retro sun effect
  for (let i = 1; i < 5; i++) {
    const ringGeometry = new THREE.RingGeometry(i * 2, i * 2 + 0.1, 32);
    const ringMaterial = new THREE.MeshBasicMaterial({
      color: i % 2 === 0 ? 0x00ffff : 0xff00ff,
      side: THREE.DoubleSide,
      transparent: true,
      opacity: 0.7
    });
    const ring = new THREE.Mesh(ringGeometry, ringMaterial);
    ring.position.z = -50;
    ring.position.y = 15;
    scene.add(ring);
  }
}

// Create the game track
function createTrack() {
  // Main track is dark with grid lines
  const trackGeometry = new THREE.PlaneGeometry(10, 1000);
  const trackMaterial = new THREE.MeshBasicMaterial({ 
    color: 0x000000,
    wireframe: false
  });
  const track = new THREE.Mesh(trackGeometry, trackMaterial);
  track.rotation.x = -Math.PI / 2;
  track.position.z = -500;
  scene.add(track);
  
  // Add prominent 80s-style neon grid lines - main visual element
  // Create multiple grid layers for more depth and visibility - moved closer to be always visible
  
  // Primary grid - positioned much closer to be immediately visible
  gridHelper = new THREE.GridHelper(100, 50, 0xff00ff, 0x00ffff);
  gridHelper.position.y = 0.01; // Just above the track
  gridHelper.position.z = -30; // Positioned much closer to be immediately visible
  // Make grid lines thicker for better visibility
  if (gridHelper.material) {
    gridHelper.material.linewidth = 2; // May not work in all browsers but worth trying
  }
  scene.add(gridHelper);
  
  // Secondary grid - also positioned closer
  const secondaryGrid = new THREE.GridHelper(200, 100, 0xff00ff, 0x00ffff);
  secondaryGrid.position.y = -0.2; // Below the main grid
  secondaryGrid.position.z = -120; // Much closer than before, but still behind primary
  secondaryGrid.material.opacity = 0.6; // More visible
  secondaryGrid.material.transparent = true;
  scene.add(secondaryGrid);
  
  // Add a third grid for even more depth effect
  const farGrid = new THREE.GridHelper(300, 150, 0xff00ff, 0x00ffff);
  farGrid.position.y = -0.4; // Even lower
  farGrid.position.z = -250; // Far but still visible
  farGrid.material.opacity = 0.3;
  farGrid.material.transparent = true;
  scene.add(farGrid);
  
  // Add lane markers
  for (let lane of lanes) {
    const markerGeometry = new THREE.PlaneGeometry(0.1, 1000);
    const markerMaterial = new THREE.MeshBasicMaterial({
      color: 0x00ffff,
      side: THREE.DoubleSide,
      transparent: true,
      opacity: 0.5
    });
    const marker = new THREE.Mesh(markerGeometry, markerMaterial);
    marker.position.x = lane;
    marker.position.y = 0.01;
    marker.position.z = -500;
    marker.rotation.x = -Math.PI / 2;
    scene.add(marker);
  }
  
  // Add side barriers with neon effect
  const leftBarrierGeometry = new THREE.BoxGeometry(0.2, 0.5, 1000);
  const rightBarrierGeometry = new THREE.BoxGeometry(0.2, 0.5, 1000);
  
  const leftBarrierMaterial = new THREE.MeshBasicMaterial({ color: 0xff00ff });
  const rightBarrierMaterial = new THREE.MeshBasicMaterial({ color: 0x00ffff });
  
  const leftBarrier = new THREE.Mesh(leftBarrierGeometry, leftBarrierMaterial);
  const rightBarrier = new THREE.Mesh(rightBarrierGeometry, rightBarrierMaterial);
  
  leftBarrier.position.x = -5.1;
  leftBarrier.position.y = 0.25;
  leftBarrier.position.z = -500;
  
  rightBarrier.position.x = 5.1;
  rightBarrier.position.y = 0.25;
  rightBarrier.position.z = -500;
  
  scene.add(leftBarrier);
  scene.add(rightBarrier);
}

// Create player - 80s style car
function createPlayer() {
  // Create car body
  const carGroup = new THREE.Group();
  
  // Main body - neon colored hovercar
  const bodyGeometry = new THREE.BoxGeometry(playerSize + 0.1, playerSize / 2, playerSize + 0.3);
  const bodyMaterial = new THREE.MeshLambertMaterial({ 
    color: 0x00ffff,
    emissive: 0x00ffff,
    emissiveIntensity: 0.5
  });
  const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
  carGroup.add(body);
  
  // Top part
  const topGeometry = new THREE.BoxGeometry(playerSize - 0.1, playerSize / 3, playerSize - 0.1);
  const topMaterial = new THREE.MeshLambertMaterial({ 
    color: 0x0000ff,
    emissive: 0x0000ff,
    emissiveIntensity: 0.2
  });
  const top = new THREE.Mesh(topGeometry, topMaterial);
  top.position.y = 0.25;
  carGroup.add(top);
  
  // Add lights for the car
  const frontLightGeometry = new THREE.BoxGeometry(0.1, 0.1, 0.1);
  const frontLightMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });
  
  const leftLight = new THREE.Mesh(frontLightGeometry, frontLightMaterial);
  leftLight.position.set(-0.2, 0, 0.3);
  carGroup.add(leftLight);
  
  const rightLight = new THREE.Mesh(frontLightGeometry, frontLightMaterial);
  rightLight.position.set(0.2, 0, 0.3);
  carGroup.add(rightLight);
  
  // Add neon glow
  const playerLight = new THREE.PointLight(0x00ffff, 1, 3);
  playerLight.position.set(0, 0.5, 0);
  carGroup.add(playerLight);
  
  // Position the whole car
  carGroup.position.y = playerSize / 2;
  carGroup.position.z = 0;
  carGroup.position.x = lanes[currentLane];
  
  player = carGroup;
  scene.add(player);
}

// Create obstacles - glitchy retro objects
function createObstacle() {
  const lane = Math.floor(Math.random() * 3);
  const obstacleType = Math.floor(Math.random() * 3);
  let obstacle;
  
  switch (obstacleType) {
    case 0: // Glitchy cube
      const cubeGroup = new THREE.Group();
      
      // Main glitchy cube
      const cubeGeometry = new THREE.BoxGeometry(1, 1, 1);
      const cubeMaterial = new THREE.MeshBasicMaterial({ 
        color: 0xff0000,
        wireframe: true,
        transparent: true,
        opacity: 0.9
      });
      const cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
      cubeGroup.add(cube);
      
      // Add glitching effect with multiple frames that randomly display
      for (let i = 0; i < 3; i++) {
        const glitchFrame = new THREE.Mesh(
          new THREE.BoxGeometry(1.2, 1.2, 1.2),
          new THREE.MeshBasicMaterial({
            color: 0xff0000,
            wireframe: true,
            transparent: true,
            opacity: 0.3
          })
        );
        glitchFrame.visible = false;
        cubeGroup.add(glitchFrame);
      }
      
      // Add intense red glow
      const cubeLight = new THREE.PointLight(0xff0000, 1, 3);
      cubeLight.position.set(0, 0, 0);
      cubeGroup.add(cubeLight);
      
      // Set up glitching animation
      setInterval(() => {
        if (cubeGroup.parent) {  // Check if still in the scene
          // Randomly show/hide glitch frames
          cubeGroup.children.forEach((child, index) => {
            if (index > 0 && index < 4) { // Skip the main cube and light
              child.visible = Math.random() > 0.7;
              child.rotation.x = Math.random() * Math.PI;
              child.rotation.z = Math.random() * Math.PI;
            }
          });
          
          // Randomly scale the main cube
          cube.scale.set(
            0.8 + Math.random() * 0.4,
            0.8 + Math.random() * 0.4,
            0.8 + Math.random() * 0.4
          );
        }
      }, 80);
      
      obstacle = cubeGroup;
      break;
      
    case 1: // VHS static-like noise
      const noiseGroup = new THREE.Group();
      
      // Create multiple glitchy planes
      for (let i = 0; i < 5; i++) {
        const noiseGeometry = new THREE.BoxGeometry(1.2, 0.1, 0.6);
        const noiseColor = (i % 2 === 0) ? 0xff3333 : 0xff0000;
        const noiseMaterial = new THREE.MeshLambertMaterial({ 
          color: noiseColor,
          emissive: noiseColor,
          emissiveIntensity: 0.9,
          transparent: true,
          opacity: 0.9
        });
        const noisePlane = new THREE.Mesh(noiseGeometry, noiseMaterial);
        noisePlane.position.y = -0.25 + (i * 0.1);
        noiseGroup.add(noisePlane);
      }
      
      // Add intense red warning light
      const noiseLight = new THREE.PointLight(0xff0000, 1.5, 4);
      noiseLight.position.set(0, 0, 0);
      noiseGroup.add(noiseLight);
      
      // Set up glitching
      setInterval(() => {
        if (noiseGroup.parent) {  // Check if still in the scene
          noiseGroup.children.forEach((child, index) => {
            if (index < 5) { // Only affect the planes, not the light
              // Randomly change opacity and position
              child.material.opacity = 0.7 + Math.random() * 0.3;
              child.position.x = (Math.random() - 0.5) * 0.3;
              child.position.y = -0.25 + (index * 0.1) + (Math.random() - 0.5) * 0.1;
              child.scale.x = 0.8 + Math.random() * 0.5;
            }
          });
        }
      }, 50);
      
      obstacle = noiseGroup;
      break;
      
    case 2: // Computer virus symbol
      const virusGroup = new THREE.Group();
      
      // Create multiple tetrahedrons that overlap
      for (let i = 0; i < 3; i++) {
        const baseGeometry = new THREE.TetrahedronGeometry(0.6, 0);
        const baseMaterial = new THREE.MeshBasicMaterial({ 
          color: 0xff0000,
          wireframe: true,
          transparent: true,
          opacity: 0.8
        });
        const baseShape = new THREE.Mesh(baseGeometry, baseMaterial);
        baseShape.rotation.set(
          Math.random() * Math.PI,
          Math.random() * Math.PI,
          Math.random() * Math.PI
        );
        virusGroup.add(baseShape);
      }
      
      // Add flashing sphere in center
      const sphereGeometry = new THREE.SphereGeometry(0.4, 8, 8);
      const sphereMaterial = new THREE.MeshBasicMaterial({
        color: 0xff0000,
        transparent: true,
        opacity: 0.7
      });
      const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
      virusGroup.add(sphere);
      
      // Stronger red warning light
      const warning = new THREE.PointLight(0xff0000, 2, 5);
      warning.position.set(0, 0, 0);
      virusGroup.add(warning);
      
      // Set up pulsing animation
      setInterval(() => {
        if (virusGroup.parent) {
          // Flash the sphere
          sphere.material.opacity = 0.4 + Math.random() * 0.6;
          sphere.scale.set(
            0.8 + Math.random() * 0.5,
            0.8 + Math.random() * 0.5,
            0.8 + Math.random() * 0.5
          );
          
          // Rotate the tetrahedrons randomly
          virusGroup.children.forEach((child, index) => {
            if (index < 3) { // Only affect the tetrahedrons
              child.rotation.x += (Math.random() - 0.5) * 0.2;
              child.rotation.z += (Math.random() - 0.5) * 0.2;
            }
          });
        }
      }, 100);
      
      obstacle = virusGroup;
      break;
  }
  
  // Position the obstacle
  obstacle.position.x = lanes[lane];
  obstacle.position.y = 0.5;
  obstacle.position.z = -100;
  obstacle.scale.set(1.2, 1.2, 1.2);
  
  scene.add(obstacle);
  obstacles.push(obstacle);
}

// Create collectible item - 80s icons with LinkedIn and GitHub data
function createCollectible() {
  const lane = Math.floor(Math.random() * 3);
  
  // Determine if this should be a LinkedIn collectible (30% chance)
  const isLinkedInItem = linkedinData.length > 0 && Math.random() < 0.3;
  
  // For standard collectibles, choose a random type
  const collectibleType = Math.floor(Math.random() * 4);
  
  let collectible;
  const colorIndex = Math.floor(Math.random() * neonColors.length);
  const itemColor = isLinkedInItem ? 0x0077B5 : neonColors[colorIndex]; // LinkedIn blue for LinkedIn items
  
  // Store the data source and item in the collectible's userData
  const userData = {};
  
  if (isLinkedInItem) {
    // Choose a random LinkedIn data item if available
    if (linkedinData && linkedinData.length > 0) {
      const randomIndex = Math.floor(Math.random() * linkedinData.length);
      userData.dataSource = 'linkedin';
      userData.dataItem = linkedinData[randomIndex];
    } else {
      // If no LinkedIn data is available yet, just mark as LinkedIn source
      userData.dataSource = 'linkedin';
      userData.dataItem = {
        name: "LinkedIn Profile",
        description: "Loading profile data...",
        type: "profile",
        color: 0x0077B5
      };
    }
    
    // For LinkedIn items, use a special shape - holographic pyramid
    const pyramidGroup = new THREE.Group();
    
    // Create outer wireframe with LinkedIn blue color
    const pyramidGeometry = new THREE.TetrahedronGeometry(0.4, 0);
    const pyramidMaterial = new THREE.MeshBasicMaterial({ 
      color: 0x0077B5, // LinkedIn blue
      wireframe: true,
      transparent: true,
      opacity: 0.8
    });
    const pyramidWireframe = new THREE.Mesh(pyramidGeometry, pyramidMaterial);
    pyramidGroup.add(pyramidWireframe);
    
    // Create inner solid with LinkedIn logo colors
    const innerGeometry = new THREE.TetrahedronGeometry(0.3, 0);
    const innerMaterial = new THREE.MeshBasicMaterial({ 
      color: 0x00A0DC, // Lighter LinkedIn blue
      transparent: true,
      opacity: 0.3
    });
    const innerPyramid = new THREE.Mesh(innerGeometry, innerMaterial);
    pyramidGroup.add(innerPyramid);
    
    // Add letter "in" on one face to represent LinkedIn
    const addLetterIn = () => {
      // Create canvas for text
      const canvas = document.createElement('canvas');
      const context = canvas.getContext('2d');
      canvas.width = 128;
      canvas.height = 128;
      
      // Draw "in" text
      context.fillStyle = '#FFFFFF';
      context.font = 'bold 80px Arial';
      context.textAlign = 'center';
      context.textBaseline = 'middle';
      context.fillText('in', 64, 64);
      
      // Create texture from canvas
      const texture = new THREE.CanvasTexture(canvas);
      
      // Create material with texture
      const material = new THREE.MeshBasicMaterial({
        map: texture,
        transparent: true,
        opacity: 0.9,
        side: THREE.DoubleSide
      });
      
      // Create plane for the face
      const plane = new THREE.PlaneGeometry(0.3, 0.3);
      const textMesh = new THREE.Mesh(plane, material);
      textMesh.position.set(0, 0.1, 0.2);
      textMesh.lookAt(0, 0.5, 1);
      
      return textMesh;
    };
    
    pyramidGroup.add(addLetterIn());
    
    // Add strong glow light
    const pyramidLight = new THREE.PointLight(0x0077B5, 1.5, 3);
    pyramidLight.position.set(0, 0, 0);
    pyramidGroup.add(pyramidLight);
    
    collectible = pyramidGroup;
    
    // Add special animation function for this collectible
    collectible.userData = {
      ...userData,
      animate: function(time) {
        // Rotate the wireframe and inner pyramid differently
        pyramidWireframe.rotation.y += 0.01;
        innerPyramid.rotation.y -= 0.005;
        innerPyramid.rotation.x += 0.003;
      }
    };
    
    return collectible;
  }
  
  // For standard collectibles, store that this is a GitHub item
  userData.dataSource = 'github';
  // We don't set userData.dataItem for GitHub items yet - that will be selected at display time
  
  switch (collectibleType) {
    case 0: // Cassette tape
      const cassetteGroup = new THREE.Group();
      
      // Create cassette body
      const tapeBody = new THREE.BoxGeometry(0.6, 0.1, 0.4);
      const tapeMaterial = new THREE.MeshBasicMaterial({ 
        color: itemColor,
        emissive: itemColor
      });
      const tape = new THREE.Mesh(tapeBody, tapeMaterial);
      cassetteGroup.add(tape);
      
      // Add cassette label
      const labelGeometry = new THREE.BoxGeometry(0.4, 0.01, 0.25);
      const labelMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
      const label = new THREE.Mesh(labelGeometry, labelMaterial);
      label.position.y = 0.06;
      cassetteGroup.add(label);
      
      // Add cassette holes
      const holeGeometry = new THREE.CylinderGeometry(0.03, 0.03, 0.12, 8);
      const holeMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
      
      const hole1 = new THREE.Mesh(holeGeometry, holeMaterial);
      hole1.rotation.z = Math.PI / 2;
      hole1.position.set(-0.15, 0, 0.2);
      cassetteGroup.add(hole1);
      
      const hole2 = new THREE.Mesh(holeGeometry, holeMaterial);
      hole2.rotation.z = Math.PI / 2;
      hole2.position.set(0.15, 0, 0.2);
      cassetteGroup.add(hole2);
      
      // Add neon glow
      const tapeLight = new THREE.PointLight(itemColor, 1, 2);
      tapeLight.position.set(0, 0, 0);
      cassetteGroup.add(tapeLight);
      
      collectible = cassetteGroup;
      break;
      
    case 1: // Retro game controller
      const controllerGroup = new THREE.Group();
      
      // Controller body
      const controllerGeometry = new THREE.BoxGeometry(0.6, 0.1, 0.4);
      const controllerMaterial = new THREE.MeshBasicMaterial({ 
        color: itemColor,
        emissive: itemColor
      });
      const controller = new THREE.Mesh(controllerGeometry, controllerMaterial);
      controllerGroup.add(controller);
      
      // D-pad
      const dpadBaseGeometry = new THREE.BoxGeometry(0.18, 0.02, 0.18);
      const dpadBaseMaterial = new THREE.MeshBasicMaterial({ color: 0x111111 });
      const dpadBase = new THREE.Mesh(dpadBaseGeometry, dpadBaseMaterial);
      dpadBase.position.set(-0.2, 0.06, 0);
      controllerGroup.add(dpadBase);
      
      // Action buttons
      const buttonGeometry = new THREE.CylinderGeometry(0.04, 0.04, 0.02, 16);
      const buttonMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
      
      const button1 = new THREE.Mesh(buttonGeometry, buttonMaterial);
      button1.rotation.x = Math.PI / 2;
      button1.position.set(0.15, 0.06, -0.05);
      controllerGroup.add(button1);
      
      const button2 = new THREE.Mesh(buttonGeometry, new THREE.MeshBasicMaterial({ color: 0x0000ff }));
      button2.rotation.x = Math.PI / 2;
      button2.position.set(0.25, 0.06, -0.05);
      controllerGroup.add(button2);
      
      // Add controller light
      const controllerLight = new THREE.PointLight(itemColor, 1, 2);
      controllerLight.position.set(0, 0.1, 0);
      controllerGroup.add(controllerLight);
      
      collectible = controllerGroup;
      break;
      
    case 2: // Vinyl record
      const recordGroup = new THREE.Group();
      
      // Main record disk
      const recordGeometry = new THREE.CylinderGeometry(0.3, 0.3, 0.02, 32);
      const recordMaterial = new THREE.MeshBasicMaterial({ color: 0x111111 });
      const record = new THREE.Mesh(recordGeometry, recordMaterial);
      record.rotation.x = Math.PI / 2;
      recordGroup.add(record);
      
      // Add record label in the center
      const labelRadius = 0.1;
      const recordLabelGeometry = new THREE.CylinderGeometry(labelRadius, labelRadius, 0.025, 32);
      const recordLabelMaterial = new THREE.MeshBasicMaterial({ color: itemColor });
      const recordLabel = new THREE.Mesh(recordLabelGeometry, recordLabelMaterial);
      recordLabel.rotation.x = Math.PI / 2;
      recordLabel.position.z = 0.003;
      recordGroup.add(recordLabel);
      
      // Add center hole
      const holeGeometry2 = new THREE.CylinderGeometry(0.02, 0.02, 0.03, 16);
      const holeMaterial2 = new THREE.MeshBasicMaterial({ color: 0x000000 });
      const hole = new THREE.Mesh(holeGeometry2, holeMaterial2);
      hole.rotation.x = Math.PI / 2;
      recordGroup.add(hole);
      
      // Add neon reflection/glow
      const recordLight = new THREE.PointLight(itemColor, 1.5, 3);
      recordLight.position.set(0, 0, 0);
      recordGroup.add(recordLight);
      
      collectible = recordGroup;
      break;
      
    case 3: // Holographic pyramid
      const pyramidGroup = new THREE.Group();
      
      // Create outer wireframe
      const pyramidGeometry = new THREE.TetrahedronGeometry(0.4, 0);
      const pyramidMaterial = new THREE.MeshBasicMaterial({ 
        color: itemColor,
        wireframe: true,
        transparent: true,
        opacity: 0.8
      });
      const pyramidWireframe = new THREE.Mesh(pyramidGeometry, pyramidMaterial);
      pyramidGroup.add(pyramidWireframe);
      
      // Create inner solid with holographic effect
      const innerGeometry = new THREE.TetrahedronGeometry(0.3, 0);
      const innerMaterial = new THREE.MeshBasicMaterial({ 
        color: 0xffffff,
        transparent: true,
        opacity: 0.3
      });
      const innerPyramid = new THREE.Mesh(innerGeometry, innerMaterial);
      pyramidGroup.add(innerPyramid);
      
      // Add strong glow light
      const pyramidLight = new THREE.PointLight(itemColor, 1.5, 3);
      pyramidLight.position.set(0, 0, 0);
      pyramidGroup.add(pyramidLight);
      
      collectible = pyramidGroup;
      
      // Add special animation function for this collectible
      collectible.userData = {
        animate: function(time) {
          // Rotate the wireframe and inner pyramid differently
          pyramidWireframe.rotation.y += 0.01;
          innerPyramid.rotation.y -= 0.005;
          innerPyramid.rotation.x += 0.003;
        }
      };
      break;
  }
  
  // Position the collectible
  collectible.position.x = lanes[lane];
  collectible.position.y = 0.5 + Math.sin(Date.now() * 0.003) * 0.2; // Floating effect
  collectible.position.z = -100 - Math.random() * 20;
  
  // Store user data in all collectible types
  try {
    // Initialize userData if it doesn't exist
    if (!collectible.userData) {
      collectible.userData = {};
    }
    
    // Add dataSource and dataItem if not already set
    if (!collectible.userData.dataSource) {
      collectible.userData.dataSource = userData.dataSource || 'github';
    }
    
    // For LinkedIn items, assign a specific LinkedIn data item if available
    if (userData.dataSource === 'linkedin' && linkedinData && linkedinData.length > 0) {
      const randomIndex = Math.floor(Math.random() * linkedinData.length);
      collectible.userData.dataItem = linkedinData[randomIndex];
    }
  } catch (error) {
    console.error('Error setting collectible userData:', error);
  }
  
  scene.add(collectible);
  collectibles.push(collectible);
}

// Handle window resize
function onWindowResize() {
  // Update camera aspect ratio
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  
  // Resize renderer
  renderer.setSize(window.innerWidth, window.innerHeight);
  
  // Re-position UI elements if needed
  if (window.innerHeight < 500) {
    // Adjust for small screens
    document.getElementById('instructions').style.display = 'none';
  } else {
    document.getElementById('instructions').style.display = 'block';
  }
}

// This function used to update score, but we've removed scoring
// Keeping an empty function to avoid breaking existing calls
function updateScore(newScore) {
  // Score tracking removed - purely for showing GitHub projects
}

// Camera shake effect (for obstacle collisions)
function shakeCamera(intensity = 0.5) {
  const originalPosition = camera.position.clone();
  const shakeDuration = 20; // frames
  let shakeFrame = 0;
  
  function doShake() {
    if (shakeFrame < shakeDuration) {
      // Calculate decreasing intensity
      const currentIntensity = intensity * (1 - shakeFrame / shakeDuration);
      
      // Apply random offset to camera
      camera.position.x = originalPosition.x + (Math.random() - 0.5) * currentIntensity;
      camera.position.y = originalPosition.y + (Math.random() - 0.5) * currentIntensity;
      
      shakeFrame++;
      requestAnimationFrame(doShake);
    } else {
      // Reset camera position after shake
      camera.position.copy(originalPosition);
    }
  }
  
  doShake();
}

// Check collisions
function checkCollisions() {
  // No obstacle collisions - only collectibles for repo display
  
  // Track if we're currently showing a repo to prevent overlapping displays
  if (!window.gameState) {
    window.gameState = {
      isShowingRepo: false,
      lastRepoShownTime: 0
    };
  }
  const currentTime = Date.now();
  const REPO_DISPLAY_COOLDOWN = 2000; // Minimum 2 seconds between repo displays

  // Check collectible collisions
  for (let i = collectibles.length - 1; i >= 0; i--) {
    const collectible = collectibles[i];
    
    // Check if collectible is too far behind
    if (collectible.position.z > 10) {
      scene.remove(collectible);
      collectibles.splice(i, 1);
      continue;
    }
    
    // Check for collectible pickup
    const distance = player.position.distanceTo(collectible.position);
    if (distance < playerSize + 0.7) {
      // Only show repo if enough time has passed since the last one
      const shouldShowRepo = !window.gameState.isShowingRepo && 
                             (currentTime - window.gameState.lastRepoShownTime > REPO_DISPLAY_COOLDOWN);
      
      // Create collection effect (potentially without showing repo)
      createCollectionEffect(collectible.position.x, collectible.position.y, collectible.position.z, shouldShowRepo);
      
      // If we're showing a repo, update our state
      if (shouldShowRepo) {
        window.gameState.isShowingRepo = true;
        window.gameState.lastRepoShownTime = currentTime;
        
        // Reset the flag after a delay to allow showing the next repo
        setTimeout(() => {
          window.gameState.isShowingRepo = false;
        }, REPO_DISPLAY_COOLDOWN);
      }
      
      // Remove collectible
      scene.remove(collectible);
      collectibles.splice(i, 1);
      
      // Occasionally flash grid for visual interest
      if (Math.random() < 0.2) { // 20% chance on collection
        flashGrid();
      }
    }
  }
}

// Create explosion effect when player hits obstacle (optimized)
function createExplosion(x, y, z) {
  const particleCount = 15; // Reduced by half for better performance
  const particles = [];
  
  // Reuse geometries and materials for better performance
  const particleGeometry = new THREE.BoxGeometry(0.1, 0.1, 0.1);
  const particleMaterial1 = new THREE.MeshBasicMaterial({
    color: 0xff0000,
    transparent: true,
    opacity: 1
  });
  const particleMaterial2 = new THREE.MeshBasicMaterial({
    color: 0xff00ff,
    transparent: true,
    opacity: 1
  });
  
  for (let i = 0; i < particleCount; i++) {
    const particle = new THREE.Mesh(
      particleGeometry,
      i % 2 === 0 ? particleMaterial1 : particleMaterial2
    );
    
    particle.position.set(x, y, z);
    particle.velocity = {
      x: (Math.random() - 0.5) * 0.2,
      y: (Math.random() - 0.5) * 0.2, 
      z: (Math.random() - 0.5) * 0.2
    };
    
    scene.add(particle);
    particles.push(particle);
  }
  
  // Animate particles
  const animateParticles = () => {
    // Always animate particles (removed gameOver check)
    particles.forEach(particle => {
      particle.position.x += particle.velocity.x;
      particle.position.y += particle.velocity.y;
      particle.position.z += particle.velocity.z;
      
      particle.material.opacity -= 0.02;
      
      if (particle.material.opacity <= 0) {
        scene.remove(particle);
      }
    });
    
    // Continue animation if particles exist
    if (particles.length > 0) {
      requestAnimationFrame(animateParticles);
    }
  };
  
  animateParticles();
}

// Create collection effect when player picks up collectible (optimized)
function createCollectionEffect(x, y, z, showRepo = true) {
  // Create expanding ring (simplified geometry for performance)
  const ringGeometry = new THREE.RingGeometry(0.1, 0.15, 16); // Reduced segments
  const ringMaterial = new THREE.MeshBasicMaterial({
    color: 0x00ffff,
    side: THREE.DoubleSide,
    transparent: true,
    opacity: 1
  });
  
  const ring = new THREE.Mesh(ringGeometry, ringMaterial);
  ring.position.set(x, y, z);
  ring.rotation.y = Math.PI / 2;
  scene.add(ring);
  
  // Create particles burst effect - fewer particles for better performance
  const particleCount = 6; // Further reduced for better performance
  const particles = [];
  
  // Reuse geometries and materials for better performance
  const particleGeometry = new THREE.BoxGeometry(0.1, 0.1, 0.1);
  const particleMaterial1 = new THREE.MeshBasicMaterial({
    color: 0x00ffff,
    transparent: true,
    opacity: 1
  });
  const particleMaterial2 = new THREE.MeshBasicMaterial({
    color: 0xff00ff,
    transparent: true,
    opacity: 1
  });
  
  for (let i = 0; i < particleCount; i++) {
    const particle = new THREE.Mesh(
      particleGeometry, 
      i % 2 === 0 ? particleMaterial1 : particleMaterial2
    );
    
    particle.position.set(x, y, z);
    particle.velocity = {
      x: (Math.random() - 0.5) * 0.1,
      y: (Math.random() - 0.5) * 0.1 + 0.05, // Slight upward bias
      z: (Math.random() - 0.5) * 0.1
    };
    
    scene.add(particle);
    particles.push(particle);
  }
  
  // Add point light flash (same as before)
  const pointLight = new THREE.PointLight(0xffffff, 2, 5);
  pointLight.position.set(x, y, z);
  scene.add(pointLight);
  
  // Display collected item info if available AND if showRepo flag is true
  if (showRepo) {
    // Check if this collectible had specific data assigned to it
    // If we can identify what this collectible is, show that specific data
    let dataSource = 'github'; // Default to GitHub
    let dataItem = null;
    
    // Use the collectible's userData directly if possible
    try {
      // Try to get from the collectible that was just collected
      const collectedItem = collectibles.find(c => 
        Math.abs(c.position.x - x) < 0.5 && 
        Math.abs(c.position.y - y) < 0.5 && 
        Math.abs(c.position.z - z) < 0.5
      );
      
      if (collectedItem && collectedItem.userData) {
        if (collectedItem.userData.dataSource) {
          dataSource = collectedItem.userData.dataSource;
        }
        if (collectedItem.userData.dataItem) {
          dataItem = collectedItem.userData.dataItem;
        }
      }
    } catch (error) {
      console.error('Error accessing collectible userData:', error);
      // Fall back to default GitHub display
    }
    
    if (dataSource === 'linkedin' && dataItem) {
      // Use the specific LinkedIn item that was assigned to this collectible
      createExplodingRepoText(new THREE.Vector3(x, y, z), dataItem);
      
      // Refresh LinkedIn data occasionally
      if (Math.random() < 0.1) { // 10% chance to refresh
        console.log('Refreshing LinkedIn data...');
        fetchLinkedInProfile().then(profile => {
          linkedinData = processLinkedInData(profile);
          console.log('LinkedIn data refreshed with', linkedinData.length, 'items');
        }).catch(err => {
          console.error('Error refreshing LinkedIn data:', err);
        });
      }
    } 
    else if (dataSource === 'github' && githubRepos && githubRepos.length > 0) {
      // Get the next repository from the front of the array (newest repos first)
      // This ensures we're always showing the most recently updated repos first
      const repo = githubRepos[0];
      
      // Create the exploding text effect with the repository info
      createExplodingRepoText(new THREE.Vector3(x, y, z), repo);
      
      // Move this repo to the end of the array to cycle through them
      // This way we show all repos before repeating
      if (githubRepos.length > 1) {
        const usedRepo = githubRepos.shift(); // Remove from front
        githubRepos.push(usedRepo); // Add to end
      }
      
      // Refresh GitHub data occasionally
      if (Math.random() < 0.05) { // 5% chance to refresh
        console.log('Refreshing GitHub repos...');
        fetchGitHubRepos().then(repos => {
          githubRepos = repos;
          console.log('GitHub repos refreshed with', githubRepos.length, 'repositories');
        }).catch(err => {
          console.error('Error refreshing GitHub data:', err);
        });
      }
    }
  }
  
  // Animate expanding ring and particles
  let scale = 0.1;
  const animate = () => {
    if (scale < 3) {
      // Animate ring
      scale += 0.15;
      ring.scale.set(scale, scale, scale);
      ring.material.opacity = 1 - scale / 3;
      ring.rotation.z += 0.02;
      
      // Animate particles
      particles.forEach(particle => {
        particle.position.x += particle.velocity.x;
        particle.position.y += particle.velocity.y;
        particle.position.z += particle.velocity.z;
        particle.material.opacity -= 0.02;
        particle.rotation.x += 0.1;
        particle.rotation.y += 0.1;
      });
      
      // Fade out light
      pointLight.intensity = 2 * (1 - scale / 3);
      
      requestAnimationFrame(animate);
    } else {
      // Clean up
      scene.remove(ring);
      particles.forEach(particle => scene.remove(particle));
      scene.remove(pointLight);
    }
  };
  
  animate();
}

// Enhanced flash grid effect for visual impact
function flashGrid() {
  const originalColors = [0xff00ff, 0x00ffff];
  let flashCount = 0;
  
  // Find all grid helpers in the scene
  const allGrids = [];
  scene.traverse(child => {
    if (child instanceof THREE.GridHelper) {
      allGrids.push(child);
    }
  });
  
  const flashInterval = setInterval(() => {
    if (flashCount < 8) { // More flashes for emphasis
      if (flashCount % 2 === 0) {
        // Flash to bright white
        allGrids.forEach(grid => {
          if (grid.material && grid.material.length >= 2) {
            grid.material[0].color.setHex(0xffffff);
            grid.material[1].color.setHex(0xffffff);
            // Increase line brightness temporarily
            grid.material[0].opacity = 1;
            grid.material[1].opacity = 1;
          }
        });
      } else {
        // Flash back to original colors
        allGrids.forEach((grid, index) => {
          if (grid.material && grid.material.length >= 2) {
            grid.material[0].color.setHex(originalColors[0]);
            grid.material[1].color.setHex(originalColors[1]);
            // Reset opacity for secondary grids
            if (grid !== gridHelper) {
              grid.material[0].opacity = 0.4;
              grid.material[1].opacity = 0.4;
            }
          }
        });
      }
      flashCount++;
    } else {
      clearInterval(flashInterval);
    }
  }, 120); // Slightly slower flash for better effect
}

// No game over functionality needed

// Start the game
function startGame() {
  gameStarted = true;
  gameOver = false; // Keep this for compatibility but don't use it
  document.getElementById('start-screen').classList.add('hidden');
  updateScore(0);
  
  // Start with an extra strong grid flash for emphasis
  setTimeout(() => {
    flashGrid();
    // Double flash for emphasis
    setTimeout(flashGrid, 800);
  }, 100);
  
  // Only create collectibles - no obstacles
  // Create more initial collectibles to increase chances of seeing repos
  for (let i = 0; i < 10; i++) {
    createCollectible();
    collectibles[i].position.z = -15 - (i * 7); // Position them at different distances
  }
  
  // Create initial welcome text displays to show the player what to expect
  setTimeout(() => {
    // First welcome message about GitHub
    const center1 = new THREE.Vector3(-2, 1.5, -5);
    const welcomeGithub = {
      name: "CATCH GITHUB REPOS",
      description: "DISCOVER MY LATEST PROJECTS",
      language: "GitHub",
      stars: 0,
      color: 0xffff00
    };
    createExplodingRepoText(center1, welcomeGithub);
    
    // Second welcome message about LinkedIn
    setTimeout(() => {
      const center2 = new THREE.Vector3(2, 1.5, -5);
      const welcomeLinkedIn = {
        name: "CATCH LINKEDIN DATA",
        description: "MY CAREER HIGHLIGHTS",
        type: "profile",
        color: 0x0077B5
      };
      createExplodingRepoText(center2, welcomeLinkedIn);
      
      // Refresh data on game start to ensure fresh content
      fetchGitHubRepos().then(repos => {
        githubRepos = repos;
        console.log('GitHub repos refreshed with', githubRepos.length, 'repositories');
      });
      
      fetchLinkedInProfile().then(profile => {
        linkedinData = processLinkedInData(profile);
        console.log('LinkedIn data refreshed with', linkedinData.length, 'items');
      });
      
    }, 800);
  }, 1000); // Show intro messages after short delays
}

// Refresh the game - can be triggered manually if needed
function refreshGame() {
  // Reset basic game parameters but don't stop gameplay
  speed = 0.2;
  level = 1;
  
  // Clear obstacles and collectibles
  for (const obstacle of obstacles) {
    scene.remove(obstacle);
  }
  obstacles = [];
  
  for (const collectible of collectibles) {
    scene.remove(collectible);
  }
  collectibles = [];
  
  // Keep current text particles - they'll fade naturally
  
  // Reset player position to current lane
  player.position.set(lanes[currentLane], playerSize / 2, 0);
  player.rotation.set(0, 0, 0);
  
  // Reset score
  updateScore(0);
  
  // Flash grid for visual effect
  flashGrid();
  
  // Use existing repo data - no additional fetch
  if (githubRepos && githubRepos.length > 0) {
    console.log('Using existing GitHub repos:', githubRepos.length);
    
    // Show newest repo as an announcement
    setTimeout(() => {
      const newestRepo = githubRepos[0];
      const center = new THREE.Vector3(0, 2, -3);
      createExplodingRepoText(center, newestRepo);
    }, 500);
  }
  
  // Create new collectibles - more of them since they're the only interactive elements
  for (let i = 0; i < 10; i++) {
    createCollectible();
    collectibles[i].position.z = -15 - (i * 6); // Position them closer together
  }
}

// Animation loop
function animate() {
  try {
    animationId = requestAnimationFrame(animate);
    
    // Always animate grid and sun, even before game starts
    // Move and animate grid - key visual element
    if (gridHelper) {
      // Animate main grid - much more controlled movement to keep visible
      gridHelper.position.z += gameStarted ? speed * 1.2 : 0.15;
      
      // Reset primary grid when it gets too close to keep the infinite effect
      // But never let it go completely out of view
      if (gridHelper.position.z > 15) { // Reset much sooner to always keep it visible
        gridHelper.position.z = -30;
      }
      
      // Animate all other grid helpers with smart distance management
      scene.children.forEach(child => {
        if (child instanceof THREE.GridHelper && child !== gridHelper) {
          // Get Z position to give appropriate speed (further = slower)
          const baseZ = Math.abs(child.position.z);
          const speedMultiplier = 1 - (baseZ / 400); // Slower if further away
          
          // Move at appropriate speed
          child.position.z += gameStarted ? speed * speedMultiplier * 1.2 : 0.1;
          
          // Ensure grid is never too far or too close
          if (child.position.z > 20) {
            // If this is the secondary grid, reset to original position
            if (baseZ < 150) {
              child.position.z = -120;
            } 
            // If this is the far grid, reset to original position
            else {
              child.position.z = -250;
            }
          }
        }
      });
      
      // Always flash the grid immediately if it's the first time running
      if (!window.gridFlashed) {
        window.gridFlashed = true;
        flashGrid();
      }
    }
    
    // Move the retro sun and stars
    if (sun) {
      sun.rotation.z += 0.005;
    }
  
    // Update exploding text particles
    for (let i = explodingTexts.length - 1; i >= 0; i--) {
      try {
        const textParticle = explodingTexts[i];
        if (!textParticle || !textParticle.update) {
          // Invalid particle, remove it
          console.warn('Invalid text particle found, removing');
          if (textParticle && textParticle.mesh) {
            scene.remove(textParticle.mesh);
          }
          explodingTexts.splice(i, 1);
          continue;
        }
        
        const isAlive = textParticle.update();
        
        if (!isAlive) {
          // Remove dead particles from scene and array
          if (textParticle.mesh) {
            scene.remove(textParticle.mesh);
          }
          explodingTexts.splice(i, 1);
        }
      } catch (err) {
        console.error('Error updating text particle:', err);
        // Remove problematic particle
        try {
          if (explodingTexts[i] && explodingTexts[i].mesh) {
            scene.remove(explodingTexts[i].mesh);
          }
        } catch (e) {
          // Ignore further errors in cleanup
        }
        explodingTexts.splice(i, 1);
      }
    }
    
    if (gameStarted) {
      // Move player to target lane if player exists
      if (player) {
        player.position.x += (lanes[currentLane] - player.position.x) * 0.1;
        
        // Rotate wheels or add hover effect
        if (player.children && player.children.length > 0) {
          player.children.forEach(child => {
            try {
              // Add slight bobbing motion to simulate hovering
              child.position.y = Math.sin(Date.now() * 0.005) * 0.03;
            } catch (e) {
              console.error('Error updating player child:', e);
            }
          });
        }
      }
      
      // Move obstacles with error handling
      for (let i = obstacles.length - 1; i >= 0; i--) {
        try {
          const obstacle = obstacles[i];
          obstacle.position.z += speed;
          
          // Different rotation effects based on obstacle type
          if (obstacle.children && obstacle.children[0] && obstacle.children[0].geometry) {
            // For group objects
            obstacle.rotation.z += 0.03;
          }
        } catch (err) {
          console.error('Error updating obstacle:', err);
          // Remove problematic obstacle
          if (obstacles[i]) {
            try {
              scene.remove(obstacles[i]);
            } catch (e) {
              // Ignore further errors
            }
            obstacles.splice(i, 1);
          }
        }
      }
      
      // Move collectibles with error handling
      for (let i = collectibles.length - 1; i >= 0; i--) {
        try {
          const collectible = collectibles[i];
          collectible.position.z += speed;
          
          // Check for special animation function
          if (collectible.userData && collectible.userData.animate) {
            collectible.userData.animate(Date.now());
          } else {
            // Different animation based on collectible type
            collectible.rotation.y += 0.02;
          }
          
          // Floating effect
          collectible.position.y = 0.5 + Math.sin(Date.now() * 0.002 + collectible.position.x) * 0.2;
        } catch (err) {
          console.error('Error updating collectible:', err);
          // Remove problematic collectible
          if (collectibles[i]) {
            try {
              scene.remove(collectibles[i]);
            } catch (e) {
              // Ignore further errors
            }
            collectibles.splice(i, 1);
          }
        }
      }
      
      // Only create collectibles - no obstacles
      try {
        // Higher chance of collectibles to ensure a steady stream
        if (Math.random() < 0.03) {
          createCollectible();
        }
        
        // Check collisions
        checkCollisions();
      } catch (err) {
        console.error('Error in game logic:', err);
      }
      
      // No refresh in animation loop - using initial data only
    }
    
    // Render scene
    if (renderer && scene && camera) {
      renderer.render(scene, camera);
    }
  } catch (err) {
    console.error('Critical error in animation loop:', err);
    // Try to recover by requesting next frame
    requestAnimationFrame(animate);
  }
}

// Initialize the game when the page loads with safety checks
document.addEventListener('DOMContentLoaded', function() {
  console.log('DOM content loaded, starting initialization...');
  
  // Check for THREE before trying to initialize
  if (typeof THREE === 'undefined') {
    console.error('THREE is not defined! Attempting to load Three.js directly...');
    
    // Try to load Three.js dynamically
    const script = document.createElement('script');
    script.src = 'https://cdn.jsdelivr.net/npm/three@0.150.1/build/three.min.js'; // Use newer version
    script.onload = function() {
      console.log('Three.js loaded successfully!');
      // Initialize game after loading
      try {
        init();
        console.log('Game initialized successfully');
      } catch (err) {
        console.error('Error during game initialization:', err);
        alert('Error initializing game. Please check the console for details.');
      }
    };
    script.onerror = function() {
      console.error('Failed to load Three.js dynamically');
      alert('Could not load Three.js library. Please refresh the page or try a different browser.');
    };
    document.head.appendChild(script);
  } else {
    // THREE is available, initialize normally
    console.log('THREE is already defined, initializing game...');
    try {
      init();
      console.log('Game initialized successfully');
    } catch (err) {
      console.error('Error during game initialization:', err);
      alert('Error initializing game. Please check the console for details.');
    }
  }
});

// Simplified global handler for spacebar - capture at window level
window.addEventListener('keydown', function(event) {
  // Handle the space key for controlling the game
  if (event.key === ' ' || event.code === 'Space') {
    // Prevent page scrolling
    event.preventDefault();
    
    // Handle game state
    if (!gameStarted) {
      startGame();
    }
  }
}, false);
</script>