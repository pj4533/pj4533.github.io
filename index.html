---
layout: default
---

<div class="home">
  <h1 class="simple-intro">hi, i'm pj. i like to code</h1>
  
  <div id="game-container">
    <div id="game-canvas"></div>
    <div id="game-ui">
      <div id="score">Score: 0</div>
      <div id="instructions">
        ← → to move left/right <br>
        Catch the neon shapes to discover my latest GitHub projects <br>
        Projects shown by most recent activity <br>
        Press R to refresh projects
      </div>
    </div>
    <div id="game-overlay">
      <div id="start-screen" class="overlay-screen">
        <div class="logo">NEON WAVE</div>
        <div class="start-button">PRESS SPACE TO START</div>
      </div>
    </div>
  </div>
</div>

<script>
// Game variables
let scene, camera, renderer, player;
let gameStarted = false;
let gameOver = false;
let score = 0;
let highScore = 0;
let speed = 0.2;
let obstacles = [];
let collectibles = [];
let level = 1;
let playerSize = 0.6;
let lanes = [-2, 0, 2];
let currentLane = 1; // Center lane (0)
let animationId;
let gridHelper;
let sunGeometry;
let sun;
let stars = [];
let neonColors = [0x00ffff, 0xff00ff, 0xffff00, 0xff0099, 0x00ff99];
let githubRepos = []; // Will hold the GitHub repository data
let explodingTexts = []; // Will hold the exploding text particles

// Fetch GitHub repositories
async function fetchGitHubRepos() {
  try {
    const username = 'pj4533';
    
    // Get repos sorted by most recently updated
    // The 'updated' sort parameter sorts by the last time the repo was pushed to
    const response = await fetch(`https://api.github.com/users/${username}/repos?sort=updated&direction=desc&per_page=50`);
    
    if (!response.ok) {
      throw new Error('Failed to fetch repositories');
    }
    
    const repos = await response.json();
    console.log('Fetched repos:', repos.length);
    
    // Filter out forks and repos without descriptions
    const filteredRepos = repos
      .filter(repo => !repo.fork && repo.description && repo.description.trim() !== '')
      .map(repo => ({
        name: repo.name,
        description: repo.description,
        url: repo.html_url,
        stars: repo.stargazers_count,
        language: repo.language,
        updated_at: repo.updated_at,
        pushed_at: repo.pushed_at, // When the repo was last pushed to
        color: neonColors[Math.floor(Math.random() * neonColors.length)]
      }));
    
    // Sort by pushed_at date (most recent commit activity first)
    filteredRepos.sort((a, b) => {
      const dateA = new Date(a.pushed_at || a.updated_at);
      const dateB = new Date(b.pushed_at || b.updated_at);
      return dateB - dateA; // Descending order (newest first)
    });
    
    console.log('Filtered repos with descriptions:', filteredRepos.length);
    
    // Log the top 5 repos to verify they're sorted correctly
    console.log('Top 5 most recent repos:');
    filteredRepos.slice(0, 5).forEach(repo => {
      console.log(`- ${repo.name}: Last updated ${new Date(repo.pushed_at || repo.updated_at).toLocaleDateString()}`);
    });
    
    return filteredRepos;
  } catch (error) {
    console.error('Error fetching GitHub repos:', error);
    // Fallback data in case the API fails
    return [
      { name: 'OpenPics', description: 'Open source iOS app for viewing images from various services', color: 0x00ffff },
      { name: 'SwiftSockets', description: 'A simple socket wrapper for Swift', color: 0xff00ff },
      { name: 'WifiMonitor', description: 'Raspberry Pi based WiFi monitoring tool', color: 0xffff00 },
      { name: 'NeonWave', description: 'A retro-styled WebGL game with Three.js', color: 0xff9900 },
      { name: 'RetroUI', description: 'Retro UI components for modern web applications', color: 0x00ff99 },
    ];
  }
}

// TextParticle class for exploding text
class TextParticle {
  constructor(text, position, color, isRepoName = false) {
    this.text = text;
    this.position = position.clone();
    this.isRepoName = isRepoName; // Flag to identify if this is a repo name (for special treatment)
    
    // Slower and more subtle movement for better readability
    this.velocity = new THREE.Vector3(
      (Math.random() - 0.5) * 0.1, // Reduced horizontal movement
      (Math.random() - 0.5) * 0.05 + 0.05, // Very gentle upward drift
      (Math.random() - 0.5) * 0.1
    );
    
    // Less rotation for better readability
    this.rotation = new THREE.Vector3(
      (Math.random() - 0.5) * 0.2, // Much less initial rotation
      (Math.random() - 0.5) * 0.2,
      (Math.random() - 0.5) * 0.2
    );
    
    // Slower rotation for better readability
    this.rotationSpeed = new THREE.Vector3(
      (Math.random() - 0.5) * 0.02, // 5x slower rotation
      (Math.random() - 0.5) * 0.02,
      (Math.random() - 0.5) * 0.02
    );
    
    this.color = color;
    this.opacity = 1;
    
    // Much larger scale, especially for repo names
    this.scale = isRepoName ? 2.5 : 1.5;
    
    // Longer life and slower fade for better readability
    this.life = 1.0;
    this.lifeSpeed = isRepoName ? 0.005 : 0.01; // 4-8x slower fade
    
    // Delay fading for repo names to ensure they can be read
    this.delayFade = isRepoName ? 60 : 20; // Frames before starting to fade
    
    this.createMesh();
  }

  createMesh() {
    // Create canvas for text
    const canvas = document.createElement('canvas');
    const context = canvas.getContext('2d');
    canvas.width = 1024; // Double resolution for better text quality
    canvas.height = 512;
    
    // Create a gradient for more appealing text
    const hexColor = this.color.toString(16).padStart(6, '0');
    const gradient = context.createLinearGradient(0, 0, canvas.width, canvas.height);
    gradient.addColorStop(0, `#${hexColor}`);
    gradient.addColorStop(1, '#ffffff');
    
    // Set font properties on the context - much larger font
    const fontSize = this.isRepoName ? 72 : 48; // Bigger font, especially for repo names
    context.font = `bold ${fontSize}px "JetBrains Mono", monospace`;
    context.fillStyle = gradient;
    context.strokeStyle = '#000000';
    context.lineWidth = 6; // Thicker outline for better readability
    context.textAlign = 'center';
    context.textBaseline = 'middle';
    
    // Clear canvas
    context.clearRect(0, 0, canvas.width, canvas.height);
    
    // Add stronger glow effect
    context.shadowColor = `#${hexColor}`;
    context.shadowBlur = 25; // Increased blur for more prominent glow
    context.shadowOffsetX = 0;
    context.shadowOffsetY = 0;
    
    // For repository names, add extra visibility features
    if (this.isRepoName) {
      // Add a dark background box for better contrast
      const textMetrics = context.measureText(this.text);
      const textWidth = textMetrics.width;
      const textHeight = fontSize * 1.2;
      
      context.fillStyle = 'rgba(0, 0, 0, 0.7)';
      context.fillRect(
        canvas.width/2 - textWidth/2 - 20,
        canvas.height/2 - textHeight/2 - 10,
        textWidth + 40,
        textHeight + 20
      );
      
      // Reset fill style to gradient
      context.fillStyle = gradient;
      
      // Add extra glow passes for repo names
      for (let i = 0; i < 3; i++) {
        context.shadowBlur = 20 - i * 5;
        context.shadowColor = `#${hexColor}`;
        context.strokeText(this.text, canvas.width / 2, canvas.height / 2);
      }
    }
    
    // Draw text (first stroke for outline, then fill)
    const textX = canvas.width / 2;
    const textY = canvas.height / 2;
    context.strokeText(this.text, textX, textY);
    context.fillText(this.text, textX, textY);
    
    // Create texture from canvas
    const texture = new THREE.CanvasTexture(canvas);
    texture.minFilter = THREE.LinearFilter;
    texture.anisotropy = 8; // Higher anisotropy for better text quality at angles
    
    // Create material with transparency
    const material = new THREE.MeshBasicMaterial({
      map: texture,
      transparent: true,
      opacity: this.opacity,
      side: THREE.DoubleSide,
      blending: THREE.AdditiveBlending, // Makes text blend better with background
      depthWrite: false, // Prevents z-fighting with other text
      depthTest: true
    });
    
    // Create plane geometry for the text
    const geometry = new THREE.PlaneGeometry(3, 1.5); // Larger plane for text
    
    // Create mesh with geometry and material
    this.mesh = new THREE.Mesh(geometry, material);
    this.mesh.position.copy(this.position);
    this.mesh.scale.set(this.scale, this.scale, this.scale);
    
    // Add the repo-text class
    this.mesh.userData.className = 'repo-text';
    
    // Always face the camera (billboard effect)
    this.mesh.lookAt(camera.position);
  }
  
  update() {
    // Update position with gentle movement
    this.position.add(this.velocity);
    this.mesh.position.copy(this.position);
    
    // Slight rotation for subtle motion but not too much to make it hard to read
    this.rotation.x += this.rotationSpeed.x;
    this.rotation.y += this.rotationSpeed.y;
    this.rotation.z += this.rotationSpeed.z;
    
    // Always look at camera first (billboard effect) then apply subtle rotation
    this.mesh.lookAt(camera.position);
    // Apply only Z rotation to keep text oriented correctly
    this.mesh.rotateZ(this.rotation.z * 0.3);
    
    // Delayed fade effect - only start fading after delay
    if (this.delayFade > 0) {
      this.delayFade--;
    } else {
      this.life -= this.lifeSpeed;
      
      // For smoother fade out, especially for repo names
      if (this.isRepoName) {
        // Repo names stay fully visible longer
        this.opacity = this.life > 0.7 ? 1.0 : this.life;
      } else {
        this.opacity = this.life;
      }
      
      this.mesh.material.opacity = this.opacity;
    }
    
    // Gentle scale increase - different for repo names vs description words
    let scaleFactor;
    if (this.isRepoName) {
      // Repo names grow more slowly
      scaleFactor = 1 + (1 - this.life) * 0.3;
    } else {
      // Description words can grow a bit more
      scaleFactor = 1 + (1 - this.life) * 0.5;
    }
    this.mesh.scale.set(this.scale * scaleFactor, this.scale * scaleFactor, this.scale * scaleFactor);
    
    // Return true if still alive, false if should be removed
    return this.life > 0;
  }
}

// Create exploding text effect for repositories
function createExplodingRepoText(position, repo) {
  console.log("Showing repo:", repo.name, repo.description);
  
  // Move repo name to a better viewing position - centered and higher
  const namePosition = position.clone();
  namePosition.y += 1.5; // Raise it up above where it was collected
  namePosition.z -= 1; // Bring slightly closer to camera for emphasis

  // Create particle for repo name with isRepoName flag set to true
  const nameParticle = new TextParticle(repo.name.toUpperCase(), namePosition, repo.color, true);
  
  // Add repo name particle to scene
  scene.add(nameParticle.mesh);
  explodingTexts.push(nameParticle);
  
  // Get description words and process them
  const descWords = repo.description.split(' ');
  const maxDescWords = Math.min(descWords.length, 15); // Allow more words with better visibility
  
  // Create a more structured layout for description words
  const wordWidthApprox = 0.6; // Approximate width per word for spacing
  const wordsPerRow = 4; // Number of words per row
  const rowHeight = 0.8; // Height between rows
  
  for (let i = 0; i < maxDescWords; i++) {
    // Create a longer delay for better reading
    setTimeout(() => {
      if (gameOver) return; // Don't add new particles if game is over
      
      const word = descWords[i];
      if (!word || word.trim().length === 0) return;
      
      // Calculate grid position for words
      const row = Math.floor(i / wordsPerRow);
      const col = i % wordsPerRow;
      
      // Position words in a more readable grid under the repo name
      const wordPosition = position.clone();
      wordPosition.x += (col - (wordsPerRow-1)/2) * wordWidthApprox; // Center horizontally
      wordPosition.y += 0.5 - (row * rowHeight); // Stack vertically below repo name
      wordPosition.z -= 0.5; // Slightly in front of the collection point
      
      // Add a little bit of randomness to prevent perfect grid
      wordPosition.x += (Math.random() - 0.5) * 0.2;
      wordPosition.y += (Math.random() - 0.5) * 0.1;
      
      // Create particle for this word with isRepoName = false
      const wordColor = neonColors[Math.floor(Math.random() * neonColors.length)];
      const wordParticle = new TextParticle(word, wordPosition, wordColor, false);
      
      scene.add(wordParticle.mesh);
      explodingTexts.push(wordParticle);
    }, 500 + i * 150); // Longer initial delay, plus slightly longer stagger for reading
  }
  
  // Add language and stars information if available
  if (repo.language || repo.stars) {
    setTimeout(() => {
      if (gameOver) return;
      
      let infoText = '';
      if (repo.language) infoText += `[${repo.language}]`;
      if (repo.stars && repo.stars > 0) infoText += ` ★ ${repo.stars}`;
      
      if (infoText) {
        // Position below the repository name
        const infoPosition = namePosition.clone();
        infoPosition.y -= 0.6;
        
        // Create info text particle with eye-catching color
        const infoParticle = new TextParticle(infoText, infoPosition, 0xffff00, false);
        scene.add(infoParticle.mesh);
        explodingTexts.push(infoParticle);
      }
    }, 300); // Show shortly after repo name
  }
}

// Initialize the game
function init() {
  // Create scene
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x000000);
  
  // Add fog for depth effect - purple fog for 80s vibe
  scene.fog = new THREE.Fog(0x110022, 8, 35);
  
  // Create camera
  camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
  camera.position.set(0, 1.5, 5);
  camera.lookAt(0, 0, -10);
  
  // Create renderer with post-processing effects
  renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.getElementById('game-canvas').appendChild(renderer.domElement);
  
  // Add lights
  const ambientLight = new THREE.AmbientLight(0x222222);
  scene.add(ambientLight);
  
  // Add point lights for neon effect
  const blueLight = new THREE.PointLight(0x00ffff, 1, 50);
  blueLight.position.set(-10, 15, -30);
  scene.add(blueLight);
  
  const pinkLight = new THREE.PointLight(0xff00ff, 1, 50);
  pinkLight.position.set(10, 15, -10);
  scene.add(pinkLight);
  
  // Create starfield backdrop
  createStarfield();
  
  // Create retro sun
  createRetroCyberpunkSun();
  
  // Create track
  createTrack();
  
  // Create player
  createPlayer();
  
  // Fetch GitHub repositories - load immediately on page load
  console.log('Loading GitHub repositories...');
  fetchGitHubRepos().then(repos => {
    githubRepos = repos;
    console.log('Loaded GitHub repos:', githubRepos.length);
    
    // Update periodically to ensure fresh content
    setInterval(() => {
      if (gameStarted) {
        fetchGitHubRepos().then(freshRepos => {
          if (freshRepos.length > 0) {
            // Compare first repo to see if there's anything new
            if (githubRepos.length === 0 || 
                freshRepos[0].name !== githubRepos[0].name || 
                freshRepos[0].updated_at !== githubRepos[0].updated_at) {
              githubRepos = freshRepos;
              console.log('Auto-updated GitHub repos:', githubRepos.length);
            }
          }
        });
      }
    }, 60000); // Check every minute for updates
  });
  
  // Handle window resize
  window.addEventListener('resize', onWindowResize, false);
  
  // Add key events listener
  document.addEventListener('keydown', handleKeyDown);
  
  // Initial UI setup
  updateScore(0);
  
  // Check local storage for high score
  if (localStorage.getItem('neonWaveHighScore')) {
    highScore = parseInt(localStorage.getItem('neonWaveHighScore'));
    document.querySelector('.high-score').innerHTML = 'HIGH SCORE: ' + highScore;
  }
  
  // Start animation loop
  animate();
}

// Handle keyboard input
function handleKeyDown(event) {
  // Prevent default action for arrow keys and space
  if (event.key === ' ' || 
      event.key === 'ArrowLeft' || 
      event.key === 'ArrowRight' || 
      event.key === 'ArrowUp' || 
      event.key === 'ArrowDown') {
    event.preventDefault();
  }
  
  // Handle spacebar to start the game
  if (event.key === ' ') {
    if (!gameStarted) {
      startGame();
      return;
    }
    
    // We can also use spacebar as an alternative to show a random repo
    if (Math.random() < 0.05) { // Increased chance to trigger fun repo fact
      if (githubRepos.length > 0) {
        const randomRepo = githubRepos[Math.floor(Math.random() * githubRepos.length)];
        
        // Create a special centered text effect
        const center = new THREE.Vector3(0, 1.5, 0);
        createExplodingRepoText(center, randomRepo);
      }
    }
  }
  
  // Add R key to refresh the game and repos
  if (event.key === 'r' || event.key === 'R') {
    if (gameStarted) {
      refreshGame();
      return;
    }
  }
  
  // Only handle movement if game is active
  if (!gameStarted) return;
  
  // Handle movement with arrow keys
  if (event.key === 'ArrowLeft') {
    if (currentLane > 0) {
      currentLane--;
      player.rotation.z = 0.2;
      setTimeout(() => {
        if (player) player.rotation.z = 0;
      }, 200);
    }
  } else if (event.key === 'ArrowRight') {
    if (currentLane < 2) {
      currentLane++;
      player.rotation.z = -0.2;
      setTimeout(() => {
        if (player) player.rotation.z = 0;
      }, 200);
    }
  }
}

// Create starfield backdrop
function createStarfield() {
  const starGeometry = new THREE.BufferGeometry();
  const starMaterial = new THREE.PointsMaterial({
    color: 0xffffff,
    size: 0.1,
  });
  
  const starVertices = [];
  for (let i = 0; i < 1000; i++) {
    const x = (Math.random() - 0.5) * 100;
    const y = (Math.random() - 0.5) * 100;
    const z = -Math.random() * 100;
    starVertices.push(x, y, z);
  }
  
  starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));
  stars = new THREE.Points(starGeometry, starMaterial);
  scene.add(stars);
}

// Create a retro cyberpunk sun
function createRetroCyberpunkSun() {
  // Create the sun circle
  sunGeometry = new THREE.CircleGeometry(10, 32);
  const sunMaterial = new THREE.MeshBasicMaterial({
    color: 0xff00ff,
    side: THREE.DoubleSide,
    wireframe: true,
  });
  
  sun = new THREE.Mesh(sunGeometry, sunMaterial);
  sun.position.z = -50;
  sun.position.y = 15;
  scene.add(sun);
  
  // Create concentric circles for retro sun effect
  for (let i = 1; i < 5; i++) {
    const ringGeometry = new THREE.RingGeometry(i * 2, i * 2 + 0.1, 32);
    const ringMaterial = new THREE.MeshBasicMaterial({
      color: i % 2 === 0 ? 0x00ffff : 0xff00ff,
      side: THREE.DoubleSide,
      transparent: true,
      opacity: 0.7
    });
    const ring = new THREE.Mesh(ringGeometry, ringMaterial);
    ring.position.z = -50;
    ring.position.y = 15;
    scene.add(ring);
  }
}

// Create the game track
function createTrack() {
  // Main track is dark with grid lines
  const trackGeometry = new THREE.PlaneGeometry(10, 1000);
  const trackMaterial = new THREE.MeshBasicMaterial({ 
    color: 0x000000,
    wireframe: false
  });
  const track = new THREE.Mesh(trackGeometry, trackMaterial);
  track.rotation.x = -Math.PI / 2;
  track.position.z = -500;
  scene.add(track);
  
  // Add 80s-style neon grid lines
  gridHelper = new THREE.GridHelper(100, 50, 0xff00ff, 0x00ffff);
  gridHelper.position.y = 0.01;
  gridHelper.position.z = -500;
  scene.add(gridHelper);
  
  // Add lane markers
  for (let lane of lanes) {
    const markerGeometry = new THREE.PlaneGeometry(0.1, 1000);
    const markerMaterial = new THREE.MeshBasicMaterial({
      color: 0x00ffff,
      side: THREE.DoubleSide,
      transparent: true,
      opacity: 0.5
    });
    const marker = new THREE.Mesh(markerGeometry, markerMaterial);
    marker.position.x = lane;
    marker.position.y = 0.01;
    marker.position.z = -500;
    marker.rotation.x = -Math.PI / 2;
    scene.add(marker);
  }
  
  // Add side barriers with neon effect
  const leftBarrierGeometry = new THREE.BoxGeometry(0.2, 0.5, 1000);
  const rightBarrierGeometry = new THREE.BoxGeometry(0.2, 0.5, 1000);
  
  const leftBarrierMaterial = new THREE.MeshBasicMaterial({ color: 0xff00ff });
  const rightBarrierMaterial = new THREE.MeshBasicMaterial({ color: 0x00ffff });
  
  const leftBarrier = new THREE.Mesh(leftBarrierGeometry, leftBarrierMaterial);
  const rightBarrier = new THREE.Mesh(rightBarrierGeometry, rightBarrierMaterial);
  
  leftBarrier.position.x = -5.1;
  leftBarrier.position.y = 0.25;
  leftBarrier.position.z = -500;
  
  rightBarrier.position.x = 5.1;
  rightBarrier.position.y = 0.25;
  rightBarrier.position.z = -500;
  
  scene.add(leftBarrier);
  scene.add(rightBarrier);
}

// Create player - 80s style car
function createPlayer() {
  // Create car body
  const carGroup = new THREE.Group();
  
  // Main body - neon colored hovercar
  const bodyGeometry = new THREE.BoxGeometry(playerSize + 0.1, playerSize / 2, playerSize + 0.3);
  const bodyMaterial = new THREE.MeshLambertMaterial({ 
    color: 0x00ffff,
    emissive: 0x00ffff,
    emissiveIntensity: 0.5
  });
  const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
  carGroup.add(body);
  
  // Top part
  const topGeometry = new THREE.BoxGeometry(playerSize - 0.1, playerSize / 3, playerSize - 0.1);
  const topMaterial = new THREE.MeshLambertMaterial({ 
    color: 0x0000ff,
    emissive: 0x0000ff,
    emissiveIntensity: 0.2
  });
  const top = new THREE.Mesh(topGeometry, topMaterial);
  top.position.y = 0.25;
  carGroup.add(top);
  
  // Add lights for the car
  const frontLightGeometry = new THREE.BoxGeometry(0.1, 0.1, 0.1);
  const frontLightMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });
  
  const leftLight = new THREE.Mesh(frontLightGeometry, frontLightMaterial);
  leftLight.position.set(-0.2, 0, 0.3);
  carGroup.add(leftLight);
  
  const rightLight = new THREE.Mesh(frontLightGeometry, frontLightMaterial);
  rightLight.position.set(0.2, 0, 0.3);
  carGroup.add(rightLight);
  
  // Add neon glow
  const playerLight = new THREE.PointLight(0x00ffff, 1, 3);
  playerLight.position.set(0, 0.5, 0);
  carGroup.add(playerLight);
  
  // Position the whole car
  carGroup.position.y = playerSize / 2;
  carGroup.position.z = 0;
  carGroup.position.x = lanes[currentLane];
  
  player = carGroup;
  scene.add(player);
}

// Create obstacles - glitchy retro objects
function createObstacle() {
  const lane = Math.floor(Math.random() * 3);
  const obstacleType = Math.floor(Math.random() * 3);
  let obstacle;
  
  switch (obstacleType) {
    case 0: // Glitchy cube
      const cubeGroup = new THREE.Group();
      
      // Main glitchy cube
      const cubeGeometry = new THREE.BoxGeometry(1, 1, 1);
      const cubeMaterial = new THREE.MeshBasicMaterial({ 
        color: 0xff0000,
        wireframe: true,
        transparent: true,
        opacity: 0.9
      });
      const cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
      cubeGroup.add(cube);
      
      // Add glitching effect with multiple frames that randomly display
      for (let i = 0; i < 3; i++) {
        const glitchFrame = new THREE.Mesh(
          new THREE.BoxGeometry(1.2, 1.2, 1.2),
          new THREE.MeshBasicMaterial({
            color: 0xff0000,
            wireframe: true,
            transparent: true,
            opacity: 0.3
          })
        );
        glitchFrame.visible = false;
        cubeGroup.add(glitchFrame);
      }
      
      // Add intense red glow
      const cubeLight = new THREE.PointLight(0xff0000, 1, 3);
      cubeLight.position.set(0, 0, 0);
      cubeGroup.add(cubeLight);
      
      // Set up glitching animation
      setInterval(() => {
        if (cubeGroup.parent) {  // Check if still in the scene
          // Randomly show/hide glitch frames
          cubeGroup.children.forEach((child, index) => {
            if (index > 0 && index < 4) { // Skip the main cube and light
              child.visible = Math.random() > 0.7;
              child.rotation.x = Math.random() * Math.PI;
              child.rotation.z = Math.random() * Math.PI;
            }
          });
          
          // Randomly scale the main cube
          cube.scale.set(
            0.8 + Math.random() * 0.4,
            0.8 + Math.random() * 0.4,
            0.8 + Math.random() * 0.4
          );
        }
      }, 80);
      
      obstacle = cubeGroup;
      break;
      
    case 1: // VHS static-like noise
      const noiseGroup = new THREE.Group();
      
      // Create multiple glitchy planes
      for (let i = 0; i < 5; i++) {
        const noiseGeometry = new THREE.BoxGeometry(1.2, 0.1, 0.6);
        const noiseColor = (i % 2 === 0) ? 0xff3333 : 0xff0000;
        const noiseMaterial = new THREE.MeshLambertMaterial({ 
          color: noiseColor,
          emissive: noiseColor,
          emissiveIntensity: 0.9,
          transparent: true,
          opacity: 0.9
        });
        const noisePlane = new THREE.Mesh(noiseGeometry, noiseMaterial);
        noisePlane.position.y = -0.25 + (i * 0.1);
        noiseGroup.add(noisePlane);
      }
      
      // Add intense red warning light
      const noiseLight = new THREE.PointLight(0xff0000, 1.5, 4);
      noiseLight.position.set(0, 0, 0);
      noiseGroup.add(noiseLight);
      
      // Set up glitching
      setInterval(() => {
        if (noiseGroup.parent) {  // Check if still in the scene
          noiseGroup.children.forEach((child, index) => {
            if (index < 5) { // Only affect the planes, not the light
              // Randomly change opacity and position
              child.material.opacity = 0.7 + Math.random() * 0.3;
              child.position.x = (Math.random() - 0.5) * 0.3;
              child.position.y = -0.25 + (index * 0.1) + (Math.random() - 0.5) * 0.1;
              child.scale.x = 0.8 + Math.random() * 0.5;
            }
          });
        }
      }, 50);
      
      obstacle = noiseGroup;
      break;
      
    case 2: // Computer virus symbol
      const virusGroup = new THREE.Group();
      
      // Create multiple tetrahedrons that overlap
      for (let i = 0; i < 3; i++) {
        const baseGeometry = new THREE.TetrahedronGeometry(0.6, 0);
        const baseMaterial = new THREE.MeshBasicMaterial({ 
          color: 0xff0000,
          wireframe: true,
          transparent: true,
          opacity: 0.8
        });
        const baseShape = new THREE.Mesh(baseGeometry, baseMaterial);
        baseShape.rotation.set(
          Math.random() * Math.PI,
          Math.random() * Math.PI,
          Math.random() * Math.PI
        );
        virusGroup.add(baseShape);
      }
      
      // Add flashing sphere in center
      const sphereGeometry = new THREE.SphereGeometry(0.4, 8, 8);
      const sphereMaterial = new THREE.MeshBasicMaterial({
        color: 0xff0000,
        transparent: true,
        opacity: 0.7
      });
      const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
      virusGroup.add(sphere);
      
      // Stronger red warning light
      const warning = new THREE.PointLight(0xff0000, 2, 5);
      warning.position.set(0, 0, 0);
      virusGroup.add(warning);
      
      // Set up pulsing animation
      setInterval(() => {
        if (virusGroup.parent) {
          // Flash the sphere
          sphere.material.opacity = 0.4 + Math.random() * 0.6;
          sphere.scale.set(
            0.8 + Math.random() * 0.5,
            0.8 + Math.random() * 0.5,
            0.8 + Math.random() * 0.5
          );
          
          // Rotate the tetrahedrons randomly
          virusGroup.children.forEach((child, index) => {
            if (index < 3) { // Only affect the tetrahedrons
              child.rotation.x += (Math.random() - 0.5) * 0.2;
              child.rotation.z += (Math.random() - 0.5) * 0.2;
            }
          });
        }
      }, 100);
      
      obstacle = virusGroup;
      break;
  }
  
  // Position the obstacle
  obstacle.position.x = lanes[lane];
  obstacle.position.y = 0.5;
  obstacle.position.z = -100;
  obstacle.scale.set(1.2, 1.2, 1.2);
  
  scene.add(obstacle);
  obstacles.push(obstacle);
}

// Create collectible item - 80s icons
function createCollectible() {
  const lane = Math.floor(Math.random() * 3);
  const collectibleType = Math.floor(Math.random() * 4);
  
  let collectible;
  const colorIndex = Math.floor(Math.random() * neonColors.length);
  const itemColor = neonColors[colorIndex];
  
  switch (collectibleType) {
    case 0: // Cassette tape
      const cassetteGroup = new THREE.Group();
      
      // Create cassette body
      const tapeBody = new THREE.BoxGeometry(0.6, 0.1, 0.4);
      const tapeMaterial = new THREE.MeshBasicMaterial({ 
        color: itemColor,
        emissive: itemColor
      });
      const tape = new THREE.Mesh(tapeBody, tapeMaterial);
      cassetteGroup.add(tape);
      
      // Add cassette label
      const labelGeometry = new THREE.BoxGeometry(0.4, 0.01, 0.25);
      const labelMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
      const label = new THREE.Mesh(labelGeometry, labelMaterial);
      label.position.y = 0.06;
      cassetteGroup.add(label);
      
      // Add cassette holes
      const holeGeometry = new THREE.CylinderGeometry(0.03, 0.03, 0.12, 8);
      const holeMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
      
      const hole1 = new THREE.Mesh(holeGeometry, holeMaterial);
      hole1.rotation.z = Math.PI / 2;
      hole1.position.set(-0.15, 0, 0.2);
      cassetteGroup.add(hole1);
      
      const hole2 = new THREE.Mesh(holeGeometry, holeMaterial);
      hole2.rotation.z = Math.PI / 2;
      hole2.position.set(0.15, 0, 0.2);
      cassetteGroup.add(hole2);
      
      // Add neon glow
      const tapeLight = new THREE.PointLight(itemColor, 1, 2);
      tapeLight.position.set(0, 0, 0);
      cassetteGroup.add(tapeLight);
      
      collectible = cassetteGroup;
      break;
      
    case 1: // Retro game controller
      const controllerGroup = new THREE.Group();
      
      // Controller body
      const controllerGeometry = new THREE.BoxGeometry(0.6, 0.1, 0.4);
      const controllerMaterial = new THREE.MeshBasicMaterial({ 
        color: itemColor,
        emissive: itemColor
      });
      const controller = new THREE.Mesh(controllerGeometry, controllerMaterial);
      controllerGroup.add(controller);
      
      // D-pad
      const dpadBaseGeometry = new THREE.BoxGeometry(0.18, 0.02, 0.18);
      const dpadBaseMaterial = new THREE.MeshBasicMaterial({ color: 0x111111 });
      const dpadBase = new THREE.Mesh(dpadBaseGeometry, dpadBaseMaterial);
      dpadBase.position.set(-0.2, 0.06, 0);
      controllerGroup.add(dpadBase);
      
      // Action buttons
      const buttonGeometry = new THREE.CylinderGeometry(0.04, 0.04, 0.02, 16);
      const buttonMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
      
      const button1 = new THREE.Mesh(buttonGeometry, buttonMaterial);
      button1.rotation.x = Math.PI / 2;
      button1.position.set(0.15, 0.06, -0.05);
      controllerGroup.add(button1);
      
      const button2 = new THREE.Mesh(buttonGeometry, new THREE.MeshBasicMaterial({ color: 0x0000ff }));
      button2.rotation.x = Math.PI / 2;
      button2.position.set(0.25, 0.06, -0.05);
      controllerGroup.add(button2);
      
      // Add controller light
      const controllerLight = new THREE.PointLight(itemColor, 1, 2);
      controllerLight.position.set(0, 0.1, 0);
      controllerGroup.add(controllerLight);
      
      collectible = controllerGroup;
      break;
      
    case 2: // Vinyl record
      const recordGroup = new THREE.Group();
      
      // Main record disk
      const recordGeometry = new THREE.CylinderGeometry(0.3, 0.3, 0.02, 32);
      const recordMaterial = new THREE.MeshBasicMaterial({ color: 0x111111 });
      const record = new THREE.Mesh(recordGeometry, recordMaterial);
      record.rotation.x = Math.PI / 2;
      recordGroup.add(record);
      
      // Add record label in the center
      const labelRadius = 0.1;
      const recordLabelGeometry = new THREE.CylinderGeometry(labelRadius, labelRadius, 0.025, 32);
      const recordLabelMaterial = new THREE.MeshBasicMaterial({ color: itemColor });
      const recordLabel = new THREE.Mesh(recordLabelGeometry, recordLabelMaterial);
      recordLabel.rotation.x = Math.PI / 2;
      recordLabel.position.z = 0.003;
      recordGroup.add(recordLabel);
      
      // Add center hole
      const holeGeometry2 = new THREE.CylinderGeometry(0.02, 0.02, 0.03, 16);
      const holeMaterial2 = new THREE.MeshBasicMaterial({ color: 0x000000 });
      const hole = new THREE.Mesh(holeGeometry2, holeMaterial2);
      hole.rotation.x = Math.PI / 2;
      recordGroup.add(hole);
      
      // Add neon reflection/glow
      const recordLight = new THREE.PointLight(itemColor, 1.5, 3);
      recordLight.position.set(0, 0, 0);
      recordGroup.add(recordLight);
      
      collectible = recordGroup;
      break;
      
    case 3: // Holographic pyramid
      const pyramidGroup = new THREE.Group();
      
      // Create outer wireframe
      const pyramidGeometry = new THREE.TetrahedronGeometry(0.4, 0);
      const pyramidMaterial = new THREE.MeshBasicMaterial({ 
        color: itemColor,
        wireframe: true,
        transparent: true,
        opacity: 0.8
      });
      const pyramidWireframe = new THREE.Mesh(pyramidGeometry, pyramidMaterial);
      pyramidGroup.add(pyramidWireframe);
      
      // Create inner solid with holographic effect
      const innerGeometry = new THREE.TetrahedronGeometry(0.3, 0);
      const innerMaterial = new THREE.MeshBasicMaterial({ 
        color: 0xffffff,
        transparent: true,
        opacity: 0.3
      });
      const innerPyramid = new THREE.Mesh(innerGeometry, innerMaterial);
      pyramidGroup.add(innerPyramid);
      
      // Add strong glow light
      const pyramidLight = new THREE.PointLight(itemColor, 1.5, 3);
      pyramidLight.position.set(0, 0, 0);
      pyramidGroup.add(pyramidLight);
      
      collectible = pyramidGroup;
      
      // Add special animation function for this collectible
      collectible.userData = {
        animate: function(time) {
          // Rotate the wireframe and inner pyramid differently
          pyramidWireframe.rotation.y += 0.01;
          innerPyramid.rotation.y -= 0.005;
          innerPyramid.rotation.x += 0.003;
        }
      };
      break;
  }
  
  // Position the collectible
  collectible.position.x = lanes[lane];
  collectible.position.y = 0.5 + Math.sin(Date.now() * 0.003) * 0.2; // Floating effect
  collectible.position.z = -100 - Math.random() * 20;
  
  scene.add(collectible);
  collectibles.push(collectible);
}

// Handle window resize
function onWindowResize() {
  // Update camera aspect ratio
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  
  // Resize renderer
  renderer.setSize(window.innerWidth, window.innerHeight);
  
  // Re-position UI elements if needed
  if (window.innerHeight < 500) {
    // Adjust for small screens
    document.getElementById('instructions').style.display = 'none';
  } else {
    document.getElementById('instructions').style.display = 'block';
  }
}

// Update game score
function updateScore(newScore) {
  score = newScore;
  document.getElementById('score').innerHTML = 'Score: ' + score;
  document.querySelector('.final-score').innerHTML = 'Score: ' + score;
  
  // Update high score if needed
  if (score > highScore) {
    highScore = score;
    document.querySelector('.high-score').innerHTML = 'HIGH SCORE: ' + highScore;
    localStorage.setItem('neonWaveHighScore', highScore);
  }
}

// Camera shake effect (for obstacle collisions)
function shakeCamera(intensity = 0.5) {
  const originalPosition = camera.position.clone();
  const shakeDuration = 20; // frames
  let shakeFrame = 0;
  
  function doShake() {
    if (shakeFrame < shakeDuration) {
      // Calculate decreasing intensity
      const currentIntensity = intensity * (1 - shakeFrame / shakeDuration);
      
      // Apply random offset to camera
      camera.position.x = originalPosition.x + (Math.random() - 0.5) * currentIntensity;
      camera.position.y = originalPosition.y + (Math.random() - 0.5) * currentIntensity;
      
      shakeFrame++;
      requestAnimationFrame(doShake);
    } else {
      // Reset camera position after shake
      camera.position.copy(originalPosition);
    }
  }
  
  doShake();
}

// Check collisions
function checkCollisions() {
  // Check obstacle collisions
  for (let i = obstacles.length - 1; i >= 0; i--) {
    const obstacle = obstacles[i];
    
    // Check if obstacle is too far behind
    if (obstacle.position.z > 10) {
      scene.remove(obstacle);
      obstacles.splice(i, 1);
      continue;
    }
    
    // Check for collision with player
    const distance = player.position.distanceTo(obstacle.position);
    if (distance < playerSize + 0.3) {
      // Create explosion effect
      createExplosion(obstacle.position.x, obstacle.position.y, obstacle.position.z);
      
      // Apply camera shake effect
      shakeCamera(0.5);
      
      // Remove obstacle
      scene.remove(obstacle);
      obstacles.splice(i, 1);
      
      // No game over - just subtract points
      updateScore(Math.max(0, score - 10));
      
      continue; // Continue checking other obstacles
    }
  }
  
  // Check collectible collisions
  for (let i = collectibles.length - 1; i >= 0; i--) {
    const collectible = collectibles[i];
    
    // Check if collectible is too far behind
    if (collectible.position.z > 10) {
      scene.remove(collectible);
      collectibles.splice(i, 1);
      continue;
    }
    
    // Check for collectible pickup
    const distance = player.position.distanceTo(collectible.position);
    if (distance < playerSize + 0.7) {
      // Create collection effect
      createCollectionEffect(collectible.position.x, collectible.position.y, collectible.position.z);
      
      // Different scores for different collectible types
      let points = 0;
      if (collectible.children[0].geometry.type === 'CylinderGeometry') {
        // Vinyl records worth more
        points = 25;
      } else if (collectible.children[0].geometry.type === 'TetrahedronGeometry') {
        // Wireframe pyramids worth the most
        points = 35;
      } else {
        // Other items
        points = 20;
      }
      
      updateScore(score + points);
      scene.remove(collectible);
      collectibles.splice(i, 1);
      
      // Speed up game slightly
      speed += 0.01;
      
      // Level up every 100 points
      if (score % 100 === 0) {
        level++;
        // Flash the grid when leveling up
        flashGrid();
      }
    }
  }
}

// Create explosion effect when player hits obstacle
function createExplosion(x, y, z) {
  const particleCount = 30;
  const particles = [];
  
  for (let i = 0; i < particleCount; i++) {
    const particle = new THREE.Mesh(
      new THREE.BoxGeometry(0.1, 0.1, 0.1),
      new THREE.MeshBasicMaterial({
        color: Math.random() > 0.5 ? 0xff0000 : 0xff00ff,
        transparent: true,
        opacity: 1
      })
    );
    
    particle.position.set(x, y, z);
    particle.velocity = {
      x: (Math.random() - 0.5) * 0.2,
      y: (Math.random() - 0.5) * 0.2,
      z: (Math.random() - 0.5) * 0.2
    };
    
    scene.add(particle);
    particles.push(particle);
  }
  
  // Animate particles
  const animateParticles = () => {
    if (gameOver) {
      particles.forEach(particle => {
        particle.position.x += particle.velocity.x;
        particle.position.y += particle.velocity.y;
        particle.position.z += particle.velocity.z;
        
        particle.material.opacity -= 0.02;
        
        if (particle.material.opacity <= 0) {
          scene.remove(particle);
        }
      });
      
      requestAnimationFrame(animateParticles);
    }
  };
  
  animateParticles();
}

// Create collection effect when player picks up collectible
function createCollectionEffect(x, y, z) {
  // Create expanding ring
  const ringGeometry = new THREE.RingGeometry(0.1, 0.15, 32);
  const ringMaterial = new THREE.MeshBasicMaterial({
    color: 0x00ffff,
    side: THREE.DoubleSide,
    transparent: true,
    opacity: 1
  });
  
  const ring = new THREE.Mesh(ringGeometry, ringMaterial);
  ring.position.set(x, y, z);
  ring.rotation.y = Math.PI / 2;
  scene.add(ring);
  
  // Create particles burst effect
  const particleCount = 10; // Reduced for better performance
  const particles = [];
  
  for (let i = 0; i < particleCount; i++) {
    const particleGeometry = new THREE.BoxGeometry(0.1, 0.1, 0.1);
    const particleMaterial = new THREE.MeshBasicMaterial({
      color: Math.random() > 0.5 ? 0x00ffff : 0xff00ff,
      transparent: true,
      opacity: 1
    });
    
    const particle = new THREE.Mesh(particleGeometry, particleMaterial);
    particle.position.set(x, y, z);
    particle.velocity = {
      x: (Math.random() - 0.5) * 0.1,
      y: (Math.random() - 0.5) * 0.1 + 0.05, // Slight upward bias
      z: (Math.random() - 0.5) * 0.1
    };
    
    scene.add(particle);
    particles.push(particle);
  }
  
  // Add point light flash
  const pointLight = new THREE.PointLight(0xffffff, 2, 5);
  pointLight.position.set(x, y, z);
  scene.add(pointLight);
  
  // Display GitHub repo info if available
  if (githubRepos && githubRepos.length > 0) {
    // Get the next repository from the front of the array (newest repos first)
    // This ensures we're always showing the most recently updated repos first
    const repo = githubRepos[0];
    
    // Create the exploding text effect with the repository info
    createExplodingRepoText(new THREE.Vector3(x, y, z), repo);
    
    // Move this repo to the end of the array to cycle through them
    // This way we show all repos before repeating
    if (githubRepos.length > 1) {
      const usedRepo = githubRepos.shift(); // Remove from front
      githubRepos.push(usedRepo); // Add to end
    }
    
    // If we have less than 5 repos, try to fetch more
    if (githubRepos.length < 5 && Math.random() < 0.3) {
      fetchGitHubRepos().then(repos => {
        if (repos.length > 0) {
          githubRepos = repos;
          console.log('Refreshed GitHub repos:', githubRepos.length);
        }
      });
    }
  }
  
  // Animate expanding ring and particles
  let scale = 0.1;
  const animate = () => {
    if (scale < 3) {
      // Animate ring
      scale += 0.15;
      ring.scale.set(scale, scale, scale);
      ring.material.opacity = 1 - scale / 3;
      ring.rotation.z += 0.02;
      
      // Animate particles
      particles.forEach(particle => {
        particle.position.x += particle.velocity.x;
        particle.position.y += particle.velocity.y;
        particle.position.z += particle.velocity.z;
        particle.material.opacity -= 0.02;
        particle.rotation.x += 0.1;
        particle.rotation.y += 0.1;
      });
      
      // Fade out light
      pointLight.intensity = 2 * (1 - scale / 3);
      
      requestAnimationFrame(animate);
    } else {
      // Clean up
      scene.remove(ring);
      particles.forEach(particle => scene.remove(particle));
      scene.remove(pointLight);
    }
  };
  
  animate();
}

// Flash grid effect when leveling up
function flashGrid() {
  const originalColors = [0xff00ff, 0x00ffff];
  let flashCount = 0;
  
  const flashInterval = setInterval(() => {
    if (flashCount < 6) {
      if (flashCount % 2 === 0) {
        // Flash to white
        gridHelper.material[0].color.setHex(0xffffff);
        gridHelper.material[1].color.setHex(0xffffff);
      } else {
        // Flash back to original colors
        gridHelper.material[0].color.setHex(originalColors[0]);
        gridHelper.material[1].color.setHex(originalColors[1]);
      }
      flashCount++;
    } else {
      clearInterval(flashInterval);
    }
  }, 100);
}

// No game over functionality needed

// Start the game
function startGame() {
  gameStarted = true;
  gameOver = false; // Keep this for compatibility but don't use it
  document.getElementById('start-screen').classList.add('hidden');
  updateScore(0);
  
  // Start with a grid flash
  flashGrid();
  
  // Create mostly collectibles to emphasize showing repos
  // Create fewer obstacles so player can focus on collecting
  for (let i = 0; i < 2; i++) {
    createObstacle();
    obstacles[i].position.z = -50 - (i * 25); // Position them further away
  }
  
  // Create more initial collectibles to increase chances of seeing repos
  for (let i = 0; i < 8; i++) {
    createCollectible();
    collectibles[i].position.z = -15 - (i * 8); // Position them at different distances
  }
  
  // Create an initial repo text display in the center to show the player what to expect
  setTimeout(() => {
    if (githubRepos && githubRepos.length > 0) {
      // Create a special intro display showing what to expect
      const center = new THREE.Vector3(0, 1.5, -5);
      const welcomeRepo = {
        name: "WELCOME",
        description: "Collect neon shapes to discover my latest GitHub projects",
        language: "JavaScript",
        color: 0xffff00
      };
      createExplodingRepoText(center, welcomeRepo);
    }
  }, 1000); // Show intro message after a short delay
}

// Refresh the game - can be triggered manually if needed
function refreshGame() {
  // Reset basic game parameters but don't stop gameplay
  speed = 0.2;
  level = 1;
  
  // Clear obstacles and collectibles
  for (const obstacle of obstacles) {
    scene.remove(obstacle);
  }
  obstacles = [];
  
  for (const collectible of collectibles) {
    scene.remove(collectible);
  }
  collectibles = [];
  
  // Keep current text particles - they'll fade naturally
  
  // Reset player position to current lane
  player.position.set(lanes[currentLane], playerSize / 2, 0);
  player.rotation.set(0, 0, 0);
  
  // Reset score
  updateScore(0);
  
  // Flash grid for visual effect
  flashGrid();
  
  // Reload GitHub repositories
  fetchGitHubRepos().then(repos => {
    if (repos.length > 0) {
      githubRepos = repos;
      console.log('Refreshed GitHub repos:', githubRepos.length);
      
      // Show newest repo as an announcement
      if (githubRepos.length > 0) {
        setTimeout(() => {
          const newestRepo = githubRepos[0];
          const center = new THREE.Vector3(0, 2, -3);
          createExplodingRepoText(center, newestRepo);
        }, 500);
      }
    }
  });
  
  // Create new collectibles
  for (let i = 0; i < 5; i++) {
    createCollectible();
    collectibles[i].position.z = -15 - (i * 8);
  }
}

// Animation loop
function animate() {
  animationId = requestAnimationFrame(animate);
  
  // Always animate grid and sun, even before game starts
  // Move and animate grid
  gridHelper.position.z += gameStarted ? speed : 0.1;
  if (gridHelper.position.z > 0) {
    gridHelper.position.z = -1000;
  }
  
  // Move the retro sun and stars
  sun.rotation.z += 0.005;
  
  // Update exploding text particles
  for (let i = explodingTexts.length - 1; i >= 0; i--) {
    const textParticle = explodingTexts[i];
    const isAlive = textParticle.update();
    
    if (!isAlive) {
      // Remove dead particles from scene and array
      scene.remove(textParticle.mesh);
      explodingTexts.splice(i, 1);
    }
  }
  
  if (gameStarted) {
    // Move player to target lane
    player.position.x += (lanes[currentLane] - player.position.x) * 0.1;
    
    // Rotate wheels or add hover effect
    if (player.children && player.children.length > 0) {
      player.children.forEach(child => {
        // Add slight bobbing motion to simulate hovering
        child.position.y = Math.sin(Date.now() * 0.005) * 0.03;
      });
    }
    
    // Move obstacles
    obstacles.forEach(obstacle => {
      obstacle.position.z += speed;
      
      // Different rotation effects based on obstacle type
      if (obstacle.children && obstacle.children[0].geometry) {
        // For group objects
        obstacle.rotation.z += 0.03;
      }
    });
    
    // Move collectibles
    collectibles.forEach(collectible => {
      collectible.position.z += speed;
      
      // Check for special animation function
      if (collectible.userData && collectible.userData.animate) {
        collectible.userData.animate(Date.now());
      } else {
        // Different animation based on collectible type
        collectible.rotation.y += 0.02;
      }
      
      // Floating effect
      collectible.position.y = 0.5 + Math.sin(Date.now() * 0.002 + collectible.position.x) * 0.2;
    });
    
    // Create more collectibles and fewer obstacles to focus on showcasing repos
    if (Math.random() < 0.01 + level * 0.002) {
      createObstacle();
    }
    
    if (Math.random() < 0.025 + level * 0.003) { // Higher chance of collectibles
      createCollectible();
    }
    
    // Check collisions
    checkCollisions();
    
    // Reload repos if needed - check more often
    if (githubRepos.length < 5 && Math.random() < 0.02) {
      fetchGitHubRepos().then(repos => {
        if (repos.length > 0) {
          githubRepos = repos;
          console.log('Reloaded GitHub repos:', githubRepos.length);
        }
      });
    }
  }
  
  // Render scene
  renderer.render(scene, camera);
}

// Initialize the game when the page loads with safety checks
document.addEventListener('DOMContentLoaded', function() {
  // Check for THREE before trying to initialize
  if (typeof THREE === 'undefined') {
    console.error('THREE is not defined! Attempting to load Three.js directly...');
    
    // Try to load Three.js dynamically
    const script = document.createElement('script');
    script.src = 'https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js';
    script.onload = function() {
      console.log('Three.js loaded successfully!');
      // Initialize game after loading
      init();
    };
    script.onerror = function() {
      console.error('Failed to load Three.js dynamically');
      alert('Could not load Three.js library. Please refresh the page or try a different browser.');
    };
    document.head.appendChild(script);
  } else {
    // THREE is available, initialize normally
    console.log('THREE is already defined, initializing game...');
    init();
  }
});

// Simplified global handler for spacebar - capture at window level
window.addEventListener('keydown', function(event) {
  // Handle the space key for controlling the game
  if (event.key === ' ' || event.code === 'Space') {
    // Prevent page scrolling
    event.preventDefault();
    
    // Handle game state
    if (!gameStarted) {
      startGame();
    }
  }
}, false);
</script>